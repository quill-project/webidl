
mod dom

use js::*

struct Event()

pub ext fun Event::from_str_mevent_init(type: String, event_init_dict: mut EventInit) -> mut Event
    = "new Event(#fun(String::as_js)(#var(type)), #fun(EventInit::as_js)(#var(event_init_dict)));"

pub ext fun Event::type(self: Event) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun Event::target(self: Event) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).target);"

pub ext fun Event::src_element(self: Event) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).srcElement);"

pub ext fun Event::current_target(self: Event) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).currentTarget);"

pub ext fun Event::event_phase(self: Event) -> Int
    = "return #fun(Int::from_js)(#var(self).eventPhase);"

pub ext fun Event::cancel_bubble(self: Event) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelBubble);"

pub ext fun Event::set_cancel_bubble(self: mut Event, value: Bool)
    = "#var(self).cancelBubble = #fun(Bool::as_js)(#var(value));"

pub ext fun Event::bubbles(self: Event) -> Bool
    = "return #fun(Bool::from_js)(#var(self).bubbles);"

pub ext fun Event::cancelable(self: Event) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelable);"

pub ext fun Event::return_value(self: Event) -> Bool
    = "return #fun(Bool::from_js)(#var(self).returnValue);"

pub ext fun Event::set_return_value(self: mut Event, value: Bool)
    = "#var(self).returnValue = #fun(Bool::as_js)(#var(value));"

pub ext fun Event::default_prevented(self: Event) -> Bool
    = "return #fun(Bool::from_js)(#var(self).defaultPrevented);"

pub ext fun Event::composed(self: Event) -> Bool
    = "return #fun(Bool::from_js)(#var(self).composed);"

pub ext fun Event::is_trusted(self: Event) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isTrusted);"

pub ext fun Event::time_stamp(self: Event) -> JsValue
    = "return #var(self).timeStamp;"

pub ext fun Event::composed_path(__self: mut Event) -> List[mut EventTarget] = "
    const r = #var(__self).composedPath();
    return #fun(List::from_js[mut EventTarget])(r);
"

pub ext fun Event::stop_propagation(__self: mut Event) -> Unit = "
    const r = #var(__self).stopPropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun Event::stop_immediate_propagation(__self: mut Event) -> Unit = "
    const r = #var(__self).stopImmediatePropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun Event::prevent_default(__self: mut Event) -> Unit = "
    const r = #var(__self).preventDefault();
    return #fun(Unit::from_js)(r);
"

pub ext fun Event::init_event(__self: mut Event, type: String, bubbles: Bool, cancelable: Bool) -> Unit = "
    const r = #var(__self).initEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)));
    return #fun(Unit::from_js)(r);
"

pub fun Event::as_js(self: Event) -> JsValue = JsValue::unsafe_from[Event](self)

pub fun Event::from_js(v: JsValue) -> mut Event = JsValue::unsafe_as[mut Event](v)

pub val Event::NONE: Int = 0
pub val Event::CAPTURING_PHASE: Int = 1
pub val Event::AT_TARGET: Int = 2
pub val Event::BUBBLING_PHASE: Int = 3

pub struct EventInit(
    bubbles: Option[Bool],
    cancelable: Option[Bool],
    composed: Option[Bool]
)

pub fun EventInit::default() -> mut EventInit
    = EventInit(Option::Some(false), Option::Some(false), Option::Some(false))

pub ext fun EventInit::from_js(value: JsValue) -> mut EventInit = "
    const r = {};
    r.bubbles = #fun(Option::from_js[Bool])(#var(value).bubbles);
    r.cancelable = #fun(Option::from_js[Bool])(#var(value).cancelable);
    r.composed = #fun(Option::from_js[Bool])(#var(value).composed);
    return r;
"

pub ext fun EventInit::as_js(self: EventInit) -> JsValue = "
    const r = {};
    r.bubbles = #fun(Option::as_js[Bool])(#var(self).bubbles);
    r.cancelable = #fun(Option::as_js[Bool])(#var(self).cancelable);
    r.composed = #fun(Option::as_js[Bool])(#var(self).composed);
    return r;
"

struct Window()

pub ext fun Window::event(self: Window) -> JsValue
    = "return #var(self).event;"

pub fun Window::as_js(self: Window) -> JsValue = JsValue::unsafe_from[Window](self)

pub fun Window::from_js(v: JsValue) -> mut Window = JsValue::unsafe_as[mut Window](v)

struct CustomEvent()

/// Converts a reference to 'CustomEvent' to a reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun CustomEvent::as_event(self: CustomEvent) -> Event = "return #var(self);"

/// Converts a mutable reference to 'CustomEvent' to a mutable reference to 'Event'.
/// This does not involve manipulating the object or reference.
pub ext fun CustomEvent::as_mevent(self: mut CustomEvent) -> mut Event = "return #var(self);"

/// Attempts to convert a reference to 'Event' to a reference to 'CustomEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'CustomEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CustomEvent::from_event(base: Event) -> CustomEvent = "
    if(#var(base) instanceof CustomEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'CustomEvent'!\");
"

/// Attempts to convert a mutable reference to 'Event' to a mutable reference to 'CustomEvent'.
/// The conversion may fail and panic if 'base' is not a reference to 'CustomEvent' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CustomEvent::from_mevent(base: mut Event) -> mut CustomEvent = "
    if(#var(base) instanceof CustomEvent) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Event' to 'CustomEvent'!\");
"

pub ext fun CustomEvent::from_str_mcustom_event_init(type: String, event_init_dict: mut CustomEventInit) -> mut CustomEvent
    = "new CustomEvent(#fun(String::as_js)(#var(type)), #fun(CustomEventInit::as_js)(#var(event_init_dict)));"

pub ext fun CustomEvent::detail(self: CustomEvent) -> JsValue
    = "return #var(self).detail;"

pub ext fun CustomEvent::type(self: CustomEvent) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun CustomEvent::target(self: CustomEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).target);"

pub ext fun CustomEvent::src_element(self: CustomEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).srcElement);"

pub ext fun CustomEvent::current_target(self: CustomEvent) -> Option[mut EventTarget]
    = "return #fun(Option::from_js[mut EventTarget])(#var(self).currentTarget);"

pub ext fun CustomEvent::event_phase(self: CustomEvent) -> Int
    = "return #fun(Int::from_js)(#var(self).eventPhase);"

pub ext fun CustomEvent::cancel_bubble(self: CustomEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelBubble);"

pub ext fun CustomEvent::set_cancel_bubble(self: mut CustomEvent, value: Bool)
    = "#var(self).cancelBubble = #fun(Bool::as_js)(#var(value));"

pub ext fun CustomEvent::bubbles(self: CustomEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).bubbles);"

pub ext fun CustomEvent::cancelable(self: CustomEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).cancelable);"

pub ext fun CustomEvent::return_value(self: CustomEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).returnValue);"

pub ext fun CustomEvent::set_return_value(self: mut CustomEvent, value: Bool)
    = "#var(self).returnValue = #fun(Bool::as_js)(#var(value));"

pub ext fun CustomEvent::default_prevented(self: CustomEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).defaultPrevented);"

pub ext fun CustomEvent::composed(self: CustomEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).composed);"

pub ext fun CustomEvent::is_trusted(self: CustomEvent) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isTrusted);"

pub ext fun CustomEvent::time_stamp(self: CustomEvent) -> JsValue
    = "return #var(self).timeStamp;"

pub ext fun CustomEvent::init_custom_event(__self: mut CustomEvent, type: String, bubbles: Bool, cancelable: Bool, detail: JsValue) -> Unit = "
    const r = #var(__self).initCustomEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)), #var(detail));
    return #fun(Unit::from_js)(r);
"

pub ext fun CustomEvent::composed_path(__self: mut CustomEvent) -> List[mut EventTarget] = "
    const r = #var(__self).composedPath();
    return #fun(List::from_js[mut EventTarget])(r);
"

pub ext fun CustomEvent::stop_propagation(__self: mut CustomEvent) -> Unit = "
    const r = #var(__self).stopPropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun CustomEvent::stop_immediate_propagation(__self: mut CustomEvent) -> Unit = "
    const r = #var(__self).stopImmediatePropagation();
    return #fun(Unit::from_js)(r);
"

pub ext fun CustomEvent::prevent_default(__self: mut CustomEvent) -> Unit = "
    const r = #var(__self).preventDefault();
    return #fun(Unit::from_js)(r);
"

pub ext fun CustomEvent::init_event(__self: mut CustomEvent, type: String, bubbles: Bool, cancelable: Bool) -> Unit = "
    const r = #var(__self).initEvent(#fun(String::as_js)(#var(type)), #fun(Bool::as_js)(#var(bubbles)), #fun(Bool::as_js)(#var(cancelable)));
    return #fun(Unit::from_js)(r);
"

pub fun CustomEvent::as_js(self: CustomEvent) -> JsValue = JsValue::unsafe_from[CustomEvent](self)

pub fun CustomEvent::from_js(v: JsValue) -> mut CustomEvent = JsValue::unsafe_as[mut CustomEvent](v)

pub val CustomEvent::NONE: Int = 0
pub val CustomEvent::CAPTURING_PHASE: Int = 1
pub val CustomEvent::AT_TARGET: Int = 2
pub val CustomEvent::BUBBLING_PHASE: Int = 3

pub struct CustomEventInit(
    detail: Option[JsValue],
    bubbles: Option[Bool],
    cancelable: Option[Bool],
    composed: Option[Bool]
)

pub fun CustomEventInit::default() -> mut CustomEventInit
    = CustomEventInit(Option::None, Option::Some(false), Option::Some(false), Option::Some(false))

/// Converts a reference to 'CustomEventInit' to a reference to 'EventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun CustomEventInit::as_event_init(self: CustomEventInit) -> EventInit = "return #var(self);"

/// Converts a mutable reference to 'CustomEventInit' to a mutable reference to 'EventInit'.
/// This does not involve manipulating the object or reference.
pub ext fun CustomEventInit::as_mevent_init(self: mut CustomEventInit) -> mut EventInit = "return #var(self);"

/// Attempts to convert a reference to 'EventInit' to a reference to 'CustomEventInit'.
/// A 'base' that is not a reference to 'CustomEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun CustomEventInit::from_event_init_unchecked(base: EventInit) -> CustomEventInit = "return #var(base);"

/// Attempts to convert a mutable reference to 'EventInit' to a mutable reference to 'CustomEventInit'.
/// A 'base' that is not a reference to 'CustomEventInit' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun CustomEventInit::from_mevent_init_unchecked(base: mut EventInit) -> mut CustomEventInit = "return #var(base);"

pub ext fun CustomEventInit::from_js(value: JsValue) -> mut CustomEventInit = "
    const r = {};
    r.detail = #fun(Option::from_js[JsValue])(#var(value).detail);
    r.bubbles = #fun(Option::from_js[Bool])(#var(value).bubbles);
    r.cancelable = #fun(Option::from_js[Bool])(#var(value).cancelable);
    r.composed = #fun(Option::from_js[Bool])(#var(value).composed);
    return r;
"

pub ext fun CustomEventInit::as_js(self: CustomEventInit) -> JsValue = "
    const r = {};
    r.detail = #fun(Option::as_js[JsValue])(#var(self).detail);
    r.bubbles = #fun(Option::as_js[Bool])(#var(self).bubbles);
    r.cancelable = #fun(Option::as_js[Bool])(#var(self).cancelable);
    r.composed = #fun(Option::as_js[Bool])(#var(self).composed);
    return r;
"

struct EventTarget()

pub ext fun EventTarget::new() -> mut EventTarget
    = "new EventTarget();"

pub ext fun EventTarget::add_event_listener(__self: mut EventTarget, type: String, callback: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).addEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(callback)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun EventTarget::remove_event_listener(__self: mut EventTarget, type: String, callback: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).removeEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(callback)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun EventTarget::dispatch_event(__self: mut EventTarget, event: mut Event) -> Bool = "
    const r = #var(__self).dispatchEvent(#fun(Event::as_js)(#var(event)));
    return #fun(Bool::from_js)(r);
"

pub fun EventTarget::as_js(self: EventTarget) -> JsValue = JsValue::unsafe_from[EventTarget](self)

pub fun EventTarget::from_js(v: JsValue) -> mut EventTarget = JsValue::unsafe_as[mut EventTarget](v)

pub struct EventListenerOptions(
    capture: Option[Bool]
)

pub fun EventListenerOptions::default() -> mut EventListenerOptions
    = EventListenerOptions(Option::Some(false))

pub ext fun EventListenerOptions::from_js(value: JsValue) -> mut EventListenerOptions = "
    const r = {};
    r.capture = #fun(Option::from_js[Bool])(#var(value).capture);
    return r;
"

pub ext fun EventListenerOptions::as_js(self: EventListenerOptions) -> JsValue = "
    const r = {};
    r.capture = #fun(Option::as_js[Bool])(#var(self).capture);
    return r;
"

pub struct AddEventListenerOptions(
    passive: Option[Bool],
    once: Option[Bool],
    signal: Option[mut AbortSignal],
    capture: Option[Bool]
)

pub fun AddEventListenerOptions::default() -> mut AddEventListenerOptions
    = AddEventListenerOptions(Option::None, Option::Some(false), Option::None, Option::Some(false))

/// Converts a reference to 'AddEventListenerOptions' to a reference to 'EventListenerOptions'.
/// This does not involve manipulating the object or reference.
pub ext fun AddEventListenerOptions::as_event_listener_options(self: AddEventListenerOptions) -> EventListenerOptions = "return #var(self);"

/// Converts a mutable reference to 'AddEventListenerOptions' to a mutable reference to 'EventListenerOptions'.
/// This does not involve manipulating the object or reference.
pub ext fun AddEventListenerOptions::as_mevent_listener_options(self: mut AddEventListenerOptions) -> mut EventListenerOptions = "return #var(self);"

/// Attempts to convert a reference to 'EventListenerOptions' to a reference to 'AddEventListenerOptions'.
/// A 'base' that is not a reference to 'AddEventListenerOptions' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun AddEventListenerOptions::from_event_listener_options_unchecked(base: EventListenerOptions) -> AddEventListenerOptions = "return #var(base);"

/// Attempts to convert a mutable reference to 'EventListenerOptions' to a mutable reference to 'AddEventListenerOptions'.
/// A 'base' that is not a reference to 'AddEventListenerOptions' RESULTS IN UNDEFINED BEHAVIOR.
/// This does not involve manipulating the object or reference.
pub ext fun AddEventListenerOptions::from_mevent_listener_options_unchecked(base: mut EventListenerOptions) -> mut AddEventListenerOptions = "return #var(base);"

pub ext fun AddEventListenerOptions::from_js(value: JsValue) -> mut AddEventListenerOptions = "
    const r = {};
    r.passive = #fun(Option::from_js[Bool])(#var(value).passive);
    r.once = #fun(Option::from_js[Bool])(#var(value).once);
    r.signal = #fun(Option::from_js[mut AbortSignal])(#var(value).signal);
    r.capture = #fun(Option::from_js[Bool])(#var(value).capture);
    return r;
"

pub ext fun AddEventListenerOptions::as_js(self: AddEventListenerOptions) -> JsValue = "
    const r = {};
    r.passive = #fun(Option::as_js[Bool])(#var(self).passive);
    r.once = #fun(Option::as_js[Bool])(#var(self).once);
    r.signal = #fun(Option::as_js[mut AbortSignal])(#var(self).signal);
    r.capture = #fun(Option::as_js[Bool])(#var(self).capture);
    return r;
"

struct AbortController()

pub ext fun AbortController::new() -> mut AbortController
    = "new AbortController();"

pub ext fun AbortController::signal(self: AbortController) -> mut AbortSignal
    = "return #fun(AbortSignal::from_js)(#var(self).signal);"

pub ext fun AbortController::abort(__self: mut AbortController, reason: JsValue) -> Unit = "
    const r = #var(__self).abort(#var(reason));
    return #fun(Unit::from_js)(r);
"

pub fun AbortController::as_js(self: AbortController) -> JsValue = JsValue::unsafe_from[AbortController](self)

pub fun AbortController::from_js(v: JsValue) -> mut AbortController = JsValue::unsafe_as[mut AbortController](v)

struct AbortSignal()

/// Converts a reference to 'AbortSignal' to a reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun AbortSignal::as_event_target(self: AbortSignal) -> EventTarget = "return #var(self);"

/// Converts a mutable reference to 'AbortSignal' to a mutable reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun AbortSignal::as_mevent_target(self: mut AbortSignal) -> mut EventTarget = "return #var(self);"

/// Attempts to convert a reference to 'EventTarget' to a reference to 'AbortSignal'.
/// The conversion may fail and panic if 'base' is not a reference to 'AbortSignal' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun AbortSignal::from_event_target(base: EventTarget) -> AbortSignal = "
    if(#var(base) instanceof AbortSignal) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'AbortSignal'!\");
"

/// Attempts to convert a mutable reference to 'EventTarget' to a mutable reference to 'AbortSignal'.
/// The conversion may fail and panic if 'base' is not a reference to 'AbortSignal' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun AbortSignal::from_mevent_target(base: mut EventTarget) -> mut AbortSignal = "
    if(#var(base) instanceof AbortSignal) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'AbortSignal'!\");
"

pub ext fun AbortSignal::aborted(self: AbortSignal) -> Bool
    = "return #fun(Bool::from_js)(#var(self).aborted);"

pub ext fun AbortSignal::reason(self: AbortSignal) -> JsValue
    = "return #var(self).reason;"

pub ext fun AbortSignal::onabort(self: AbortSignal) -> JsValue
    = "return #var(self).onabort;"

pub ext fun AbortSignal::set_onabort(self: mut AbortSignal, value: JsValue)
    = "#var(self).onabort = #var(value);"

pub ext fun AbortSignal::abort(reason: JsValue) -> mut AbortSignal = "
    const r = AbortSignal.abort(#var(reason));
    return #fun(AbortSignal::from_js)(r);
"

pub ext fun AbortSignal::timeout(milliseconds: Int) -> mut AbortSignal = "
    const r = AbortSignal.timeout(#fun(Int::as_js)(#var(milliseconds)));
    return #fun(AbortSignal::from_js)(r);
"

pub ext fun AbortSignal::any(signals: List[mut AbortSignal]) -> mut AbortSignal = "
    const r = AbortSignal.any(#fun(List::as_js[mut AbortSignal])(#var(signals)));
    return #fun(AbortSignal::from_js)(r);
"

pub ext fun AbortSignal::throw_if_aborted(__self: mut AbortSignal) -> Unit = "
    const r = #var(__self).throwIfAborted();
    return #fun(Unit::from_js)(r);
"

pub ext fun AbortSignal::add_event_listener(__self: mut AbortSignal, type: String, callback: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).addEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(callback)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun AbortSignal::remove_event_listener(__self: mut AbortSignal, type: String, callback: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).removeEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(callback)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun AbortSignal::dispatch_event(__self: mut AbortSignal, event: mut Event) -> Bool = "
    const r = #var(__self).dispatchEvent(#fun(Event::as_js)(#var(event)));
    return #fun(Bool::from_js)(r);
"

pub fun AbortSignal::as_js(self: AbortSignal) -> JsValue = JsValue::unsafe_from[AbortSignal](self)

pub fun AbortSignal::from_js(v: JsValue) -> mut AbortSignal = JsValue::unsafe_as[mut AbortSignal](v)

struct NodeList()

pub ext fun NodeList::length(self: NodeList) -> Int
    = "return #fun(Int::from_js)(#var(self).length);"

pub ext fun NodeList::item(__self: mut NodeList, index: Int) -> Option[mut Node] = "
    const r = #var(__self).item(#fun(Int::as_js)(#var(index)));
    return #fun(Option::from_js[mut Node])(r);
"

pub fun NodeList::as_js(self: NodeList) -> JsValue = JsValue::unsafe_from[NodeList](self)

pub fun NodeList::from_js(v: JsValue) -> mut NodeList = JsValue::unsafe_as[mut NodeList](v)

struct HTMLCollection()

pub ext fun HTMLCollection::length(self: HTMLCollection) -> Int
    = "return #fun(Int::from_js)(#var(self).length);"

pub ext fun HTMLCollection::item(__self: mut HTMLCollection, index: Int) -> Option[mut Element] = "
    const r = #var(__self).item(#fun(Int::as_js)(#var(index)));
    return #fun(Option::from_js[mut Element])(r);
"

pub ext fun HTMLCollection::named_item(__self: mut HTMLCollection, name: String) -> Option[mut Element] = "
    const r = #var(__self).namedItem(#fun(String::as_js)(#var(name)));
    return #fun(Option::from_js[mut Element])(r);
"

pub fun HTMLCollection::as_js(self: HTMLCollection) -> JsValue = JsValue::unsafe_from[HTMLCollection](self)

pub fun HTMLCollection::from_js(v: JsValue) -> mut HTMLCollection = JsValue::unsafe_as[mut HTMLCollection](v)

struct MutationObserver()

pub ext fun MutationObserver::from_f_list_mmutation_record_mmutation_observer_unit(callback: Fun(List[mut MutationRecord], mut MutationObserver) -> Unit) -> mut MutationObserver
    = "new MutationObserver(((p0, p1) => { const r = #var(callback)(#fun(List::from_js[mut MutationRecord])(p0), #fun(MutationObserver::from_js)(p1)); return #fun(Unit::as_js)(r); }));"

pub ext fun MutationObserver::observe(__self: mut MutationObserver, target: mut Node, options: mut MutationObserverInit) -> Unit = "
    const r = #var(__self).observe(#fun(Node::as_js)(#var(target)), #fun(MutationObserverInit::as_js)(#var(options)));
    return #fun(Unit::from_js)(r);
"

pub ext fun MutationObserver::disconnect(__self: mut MutationObserver) -> Unit = "
    const r = #var(__self).disconnect();
    return #fun(Unit::from_js)(r);
"

pub ext fun MutationObserver::take_records(__self: mut MutationObserver) -> List[mut MutationRecord] = "
    const r = #var(__self).takeRecords();
    return #fun(List::from_js[mut MutationRecord])(r);
"

pub fun MutationObserver::as_js(self: MutationObserver) -> JsValue = JsValue::unsafe_from[MutationObserver](self)

pub fun MutationObserver::from_js(v: JsValue) -> mut MutationObserver = JsValue::unsafe_as[mut MutationObserver](v)

pub struct MutationObserverInit(
    child_list: Option[Bool],
    attributes: Option[Bool],
    character_data: Option[Bool],
    subtree: Option[Bool],
    attribute_old_value: Option[Bool],
    character_data_old_value: Option[Bool],
    attribute_filter: Option[List[String]]
)

pub fun MutationObserverInit::default() -> mut MutationObserverInit
    = MutationObserverInit(Option::Some(false), Option::None, Option::None, Option::Some(false), Option::None, Option::None, Option::None)

pub ext fun MutationObserverInit::from_js(value: JsValue) -> mut MutationObserverInit = "
    const r = {};
    r.child_list = #fun(Option::from_js[Bool])(#var(value).childList);
    r.attributes = #fun(Option::from_js[Bool])(#var(value).attributes);
    r.character_data = #fun(Option::from_js[Bool])(#var(value).characterData);
    r.subtree = #fun(Option::from_js[Bool])(#var(value).subtree);
    r.attribute_old_value = #fun(Option::from_js[Bool])(#var(value).attributeOldValue);
    r.character_data_old_value = #fun(Option::from_js[Bool])(#var(value).characterDataOldValue);
    r.attribute_filter = #fun(Option::from_js[List[String]])(#var(value).attributeFilter);
    return r;
"

pub ext fun MutationObserverInit::as_js(self: MutationObserverInit) -> JsValue = "
    const r = {};
    r.childList = #fun(Option::as_js[Bool])(#var(self).child_list);
    r.attributes = #fun(Option::as_js[Bool])(#var(self).attributes);
    r.characterData = #fun(Option::as_js[Bool])(#var(self).character_data);
    r.subtree = #fun(Option::as_js[Bool])(#var(self).subtree);
    r.attributeOldValue = #fun(Option::as_js[Bool])(#var(self).attribute_old_value);
    r.characterDataOldValue = #fun(Option::as_js[Bool])(#var(self).character_data_old_value);
    r.attributeFilter = #fun(Option::as_js[List[String]])(#var(self).attribute_filter);
    return r;
"

struct MutationRecord()

pub ext fun MutationRecord::type(self: MutationRecord) -> String
    = "return #fun(String::from_js)(#var(self).type);"

pub ext fun MutationRecord::target(self: MutationRecord) -> mut Node
    = "return #fun(Node::from_js)(#var(self).target);"

pub ext fun MutationRecord::added_nodes(self: MutationRecord) -> mut NodeList
    = "return #fun(NodeList::from_js)(#var(self).addedNodes);"

pub ext fun MutationRecord::removed_nodes(self: MutationRecord) -> mut NodeList
    = "return #fun(NodeList::from_js)(#var(self).removedNodes);"

pub ext fun MutationRecord::previous_sibling(self: MutationRecord) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).previousSibling);"

pub ext fun MutationRecord::next_sibling(self: MutationRecord) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).nextSibling);"

pub ext fun MutationRecord::attribute_name(self: MutationRecord) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).attributeName);"

pub ext fun MutationRecord::attribute_namespace(self: MutationRecord) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).attributeNamespace);"

pub ext fun MutationRecord::old_value(self: MutationRecord) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).oldValue);"

pub fun MutationRecord::as_js(self: MutationRecord) -> JsValue = JsValue::unsafe_from[MutationRecord](self)

pub fun MutationRecord::from_js(v: JsValue) -> mut MutationRecord = JsValue::unsafe_as[mut MutationRecord](v)

struct Node()

/// Converts a reference to 'Node' to a reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun Node::as_event_target(self: Node) -> EventTarget = "return #var(self);"

/// Converts a mutable reference to 'Node' to a mutable reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun Node::as_mevent_target(self: mut Node) -> mut EventTarget = "return #var(self);"

/// Attempts to convert a reference to 'EventTarget' to a reference to 'Node'.
/// The conversion may fail and panic if 'base' is not a reference to 'Node' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Node::from_event_target(base: EventTarget) -> Node = "
    if(#var(base) instanceof Node) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'Node'!\");
"

/// Attempts to convert a mutable reference to 'EventTarget' to a mutable reference to 'Node'.
/// The conversion may fail and panic if 'base' is not a reference to 'Node' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Node::from_mevent_target(base: mut EventTarget) -> mut Node = "
    if(#var(base) instanceof Node) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'Node'!\");
"

pub ext fun Node::node_type(self: Node) -> Int
    = "return #fun(Int::from_js)(#var(self).nodeType);"

pub ext fun Node::node_name(self: Node) -> String
    = "return #fun(String::from_js)(#var(self).nodeName);"

pub ext fun Node::base_uri(self: Node) -> String
    = "return #fun(String::from_js)(#var(self).baseURI);"

pub ext fun Node::is_connected(self: Node) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isConnected);"

pub ext fun Node::owner_document(self: Node) -> Option[mut Document]
    = "return #fun(Option::from_js[mut Document])(#var(self).ownerDocument);"

pub ext fun Node::parent_node(self: Node) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).parentNode);"

pub ext fun Node::parent_element(self: Node) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).parentElement);"

pub ext fun Node::child_nodes(self: Node) -> mut NodeList
    = "return #fun(NodeList::from_js)(#var(self).childNodes);"

pub ext fun Node::first_child(self: Node) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).firstChild);"

pub ext fun Node::last_child(self: Node) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).lastChild);"

pub ext fun Node::previous_sibling(self: Node) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).previousSibling);"

pub ext fun Node::next_sibling(self: Node) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).nextSibling);"

pub ext fun Node::node_value(self: Node) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).nodeValue);"

pub ext fun Node::set_node_value(self: mut Node, value: Option[String])
    = "#var(self).nodeValue = #fun(Option::as_js[String])(#var(value));"

pub ext fun Node::text_content(self: Node) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).textContent);"

pub ext fun Node::set_text_content(self: mut Node, value: Option[String])
    = "#var(self).textContent = #fun(Option::as_js[String])(#var(value));"

pub ext fun Node::get_root_node(__self: mut Node, options: mut GetRootNodeOptions) -> mut Node = "
    const r = #var(__self).getRootNode(#fun(GetRootNodeOptions::as_js)(#var(options)));
    return #fun(Node::from_js)(r);
"

pub ext fun Node::has_child_nodes(__self: mut Node) -> Bool = "
    const r = #var(__self).hasChildNodes();
    return #fun(Bool::from_js)(r);
"

pub ext fun Node::normalize(__self: mut Node) -> Unit = "
    const r = #var(__self).normalize();
    return #fun(Unit::from_js)(r);
"

pub ext fun Node::clone_node(__self: mut Node, subtree: Bool) -> mut Node = "
    const r = #var(__self).cloneNode(#fun(Bool::as_js)(#var(subtree)));
    return #fun(Node::from_js)(r);
"

pub ext fun Node::is_equal_node(__self: mut Node, other_node: Option[mut Node]) -> Bool = "
    const r = #var(__self).isEqualNode(#fun(Option::as_js[mut Node])(#var(other_node)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Node::is_same_node(__self: mut Node, other_node: Option[mut Node]) -> Bool = "
    const r = #var(__self).isSameNode(#fun(Option::as_js[mut Node])(#var(other_node)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Node::compare_document_position(__self: mut Node, other: mut Node) -> Int = "
    const r = #var(__self).compareDocumentPosition(#fun(Node::as_js)(#var(other)));
    return #fun(Int::from_js)(r);
"

pub ext fun Node::contains(__self: mut Node, other: Option[mut Node]) -> Bool = "
    const r = #var(__self).contains(#fun(Option::as_js[mut Node])(#var(other)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Node::lookup_prefix(__self: mut Node, namespace: Option[String]) -> Option[String] = "
    const r = #var(__self).lookupPrefix(#fun(Option::as_js[String])(#var(namespace)));
    return #fun(Option::from_js[String])(r);
"

pub ext fun Node::lookup_namespace_uri(__self: mut Node, prefix: Option[String]) -> Option[String] = "
    const r = #var(__self).lookupNamespaceURI(#fun(Option::as_js[String])(#var(prefix)));
    return #fun(Option::from_js[String])(r);
"

pub ext fun Node::is_default_namespace(__self: mut Node, namespace: Option[String]) -> Bool = "
    const r = #var(__self).isDefaultNamespace(#fun(Option::as_js[String])(#var(namespace)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Node::insert_before(__self: mut Node, node: mut Node, child: Option[mut Node]) -> mut Node = "
    const r = #var(__self).insertBefore(#fun(Node::as_js)(#var(node)), #fun(Option::as_js[mut Node])(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun Node::append_child(__self: mut Node, node: mut Node) -> mut Node = "
    const r = #var(__self).appendChild(#fun(Node::as_js)(#var(node)));
    return #fun(Node::from_js)(r);
"

pub ext fun Node::replace_child(__self: mut Node, node: mut Node, child: mut Node) -> mut Node = "
    const r = #var(__self).replaceChild(#fun(Node::as_js)(#var(node)), #fun(Node::as_js)(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun Node::remove_child(__self: mut Node, child: mut Node) -> mut Node = "
    const r = #var(__self).removeChild(#fun(Node::as_js)(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun Node::add_event_listener(__self: mut Node, type: String, callback: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).addEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(callback)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun Node::remove_event_listener(__self: mut Node, type: String, callback: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).removeEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(callback)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun Node::dispatch_event(__self: mut Node, event: mut Event) -> Bool = "
    const r = #var(__self).dispatchEvent(#fun(Event::as_js)(#var(event)));
    return #fun(Bool::from_js)(r);
"

pub fun Node::as_js(self: Node) -> JsValue = JsValue::unsafe_from[Node](self)

pub fun Node::from_js(v: JsValue) -> mut Node = JsValue::unsafe_as[mut Node](v)

pub val Node::ELEMENT_NODE: Int = 1
pub val Node::ATTRIBUTE_NODE: Int = 2
pub val Node::TEXT_NODE: Int = 3
pub val Node::CDATA_SECTION_NODE: Int = 4
pub val Node::ENTITY_REFERENCE_NODE: Int = 5
pub val Node::ENTITY_NODE: Int = 6
pub val Node::PROCESSING_INSTRUCTION_NODE: Int = 7
pub val Node::COMMENT_NODE: Int = 8
pub val Node::DOCUMENT_NODE: Int = 9
pub val Node::DOCUMENT_TYPE_NODE: Int = 10
pub val Node::DOCUMENT_FRAGMENT_NODE: Int = 11
pub val Node::NOTATION_NODE: Int = 12
pub val Node::DOCUMENT_POSITION_DISCONNECTED: Int = 1
pub val Node::DOCUMENT_POSITION_PRECEDING: Int = 2
pub val Node::DOCUMENT_POSITION_FOLLOWING: Int = 4
pub val Node::DOCUMENT_POSITION_CONTAINS: Int = 8
pub val Node::DOCUMENT_POSITION_CONTAINED_BY: Int = 16
pub val Node::DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Int = 32

pub struct GetRootNodeOptions(
    composed: Option[Bool]
)

pub fun GetRootNodeOptions::default() -> mut GetRootNodeOptions
    = GetRootNodeOptions(Option::Some(false))

pub ext fun GetRootNodeOptions::from_js(value: JsValue) -> mut GetRootNodeOptions = "
    const r = {};
    r.composed = #fun(Option::from_js[Bool])(#var(value).composed);
    return r;
"

pub ext fun GetRootNodeOptions::as_js(self: GetRootNodeOptions) -> JsValue = "
    const r = {};
    r.composed = #fun(Option::as_js[Bool])(#var(self).composed);
    return r;
"

struct Document()

/// Converts a reference to 'Document' to a reference to 'Node'.
/// This does not involve manipulating the object or reference.
pub ext fun Document::as_node(self: Document) -> Node = "return #var(self);"

/// Converts a mutable reference to 'Document' to a mutable reference to 'Node'.
/// This does not involve manipulating the object or reference.
pub ext fun Document::as_mnode(self: mut Document) -> mut Node = "return #var(self);"

/// Attempts to convert a reference to 'Node' to a reference to 'Document'.
/// The conversion may fail and panic if 'base' is not a reference to 'Document' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Document::from_node(base: Node) -> Document = "
    if(#var(base) instanceof Document) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Node' to 'Document'!\");
"

/// Attempts to convert a mutable reference to 'Node' to a mutable reference to 'Document'.
/// The conversion may fail and panic if 'base' is not a reference to 'Document' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Document::from_mnode(base: mut Node) -> mut Document = "
    if(#var(base) instanceof Document) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Node' to 'Document'!\");
"

/// Converts a reference to 'Document' to a reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun Document::as_event_target(self: Document) -> EventTarget = "return #var(self);"

/// Converts a mutable reference to 'Document' to a mutable reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun Document::as_mevent_target(self: mut Document) -> mut EventTarget = "return #var(self);"

/// Attempts to convert a reference to 'EventTarget' to a reference to 'Document'.
/// The conversion may fail and panic if 'base' is not a reference to 'Document' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Document::from_event_target(base: EventTarget) -> Document = "
    if(#var(base) instanceof Document) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'Document'!\");
"

/// Attempts to convert a mutable reference to 'EventTarget' to a mutable reference to 'Document'.
/// The conversion may fail and panic if 'base' is not a reference to 'Document' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Document::from_mevent_target(base: mut EventTarget) -> mut Document = "
    if(#var(base) instanceof Document) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'Document'!\");
"

pub ext fun Document::new() -> mut Document
    = "new Document();"

pub ext fun Document::implementation(self: Document) -> mut DOMImplementation
    = "return #fun(DOMImplementation::from_js)(#var(self).implementation);"

pub ext fun Document::url(self: Document) -> String
    = "return #fun(String::from_js)(#var(self).URL);"

pub ext fun Document::document_uri(self: Document) -> String
    = "return #fun(String::from_js)(#var(self).documentURI);"

pub ext fun Document::compat_mode(self: Document) -> String
    = "return #fun(String::from_js)(#var(self).compatMode);"

pub ext fun Document::character_set(self: Document) -> String
    = "return #fun(String::from_js)(#var(self).characterSet);"

pub ext fun Document::charset(self: Document) -> String
    = "return #fun(String::from_js)(#var(self).charset);"

pub ext fun Document::input_encoding(self: Document) -> String
    = "return #fun(String::from_js)(#var(self).inputEncoding);"

pub ext fun Document::content_type(self: Document) -> String
    = "return #fun(String::from_js)(#var(self).contentType);"

pub ext fun Document::doctype(self: Document) -> Option[mut DocumentType]
    = "return #fun(Option::from_js[mut DocumentType])(#var(self).doctype);"

pub ext fun Document::document_element(self: Document) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).documentElement);"

pub ext fun Document::node_type(self: Document) -> Int
    = "return #fun(Int::from_js)(#var(self).nodeType);"

pub ext fun Document::node_name(self: Document) -> String
    = "return #fun(String::from_js)(#var(self).nodeName);"

pub ext fun Document::base_uri(self: Document) -> String
    = "return #fun(String::from_js)(#var(self).baseURI);"

pub ext fun Document::is_connected(self: Document) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isConnected);"

pub ext fun Document::owner_document(self: Document) -> Option[mut Document]
    = "return #fun(Option::from_js[mut Document])(#var(self).ownerDocument);"

pub ext fun Document::parent_node(self: Document) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).parentNode);"

pub ext fun Document::parent_element(self: Document) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).parentElement);"

pub ext fun Document::child_nodes(self: Document) -> mut NodeList
    = "return #fun(NodeList::from_js)(#var(self).childNodes);"

pub ext fun Document::first_child(self: Document) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).firstChild);"

pub ext fun Document::last_child(self: Document) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).lastChild);"

pub ext fun Document::previous_sibling(self: Document) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).previousSibling);"

pub ext fun Document::next_sibling(self: Document) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).nextSibling);"

pub ext fun Document::node_value(self: Document) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).nodeValue);"

pub ext fun Document::set_node_value(self: mut Document, value: Option[String])
    = "#var(self).nodeValue = #fun(Option::as_js[String])(#var(value));"

pub ext fun Document::text_content(self: Document) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).textContent);"

pub ext fun Document::set_text_content(self: mut Document, value: Option[String])
    = "#var(self).textContent = #fun(Option::as_js[String])(#var(value));"

pub ext fun Document::custom_element_registry(self: Document) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).customElementRegistry);"

pub ext fun Document::children(self: Document) -> mut HTMLCollection
    = "return #fun(HTMLCollection::from_js)(#var(self).children);"

pub ext fun Document::first_element_child(self: Document) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).firstElementChild);"

pub ext fun Document::last_element_child(self: Document) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).lastElementChild);"

pub ext fun Document::child_element_count(self: Document) -> Int
    = "return #fun(Int::from_js)(#var(self).childElementCount);"

pub ext fun Document::get_elements_by_tag_name(__self: mut Document, qualified_name: String) -> mut HTMLCollection = "
    const r = #var(__self).getElementsByTagName(#fun(String::as_js)(#var(qualified_name)));
    return #fun(HTMLCollection::from_js)(r);
"

pub ext fun Document::get_elements_by_tag_name_ns(__self: mut Document, namespace: Option[String], local_name: String) -> mut HTMLCollection = "
    const r = #var(__self).getElementsByTagNameNS(#fun(Option::as_js[String])(#var(namespace)), #fun(String::as_js)(#var(local_name)));
    return #fun(HTMLCollection::from_js)(r);
"

pub ext fun Document::get_elements_by_class_name(__self: mut Document, class_names: String) -> mut HTMLCollection = "
    const r = #var(__self).getElementsByClassName(#fun(String::as_js)(#var(class_names)));
    return #fun(HTMLCollection::from_js)(r);
"

pub ext fun Document::create_element(__self: mut Document, local_name: String, options: JsValue) -> mut Element = "
    const r = #var(__self).createElement(#fun(String::as_js)(#var(local_name)), #var(options));
    return #fun(Element::from_js)(r);
"

pub ext fun Document::create_element_ns(__self: mut Document, namespace: Option[String], qualified_name: String, options: JsValue) -> mut Element = "
    const r = #var(__self).createElementNS(#fun(Option::as_js[String])(#var(namespace)), #fun(String::as_js)(#var(qualified_name)), #var(options));
    return #fun(Element::from_js)(r);
"

pub ext fun Document::create_document_fragment(__self: mut Document) -> mut DocumentFragment = "
    const r = #var(__self).createDocumentFragment();
    return #fun(DocumentFragment::from_js)(r);
"

pub ext fun Document::create_text_node(__self: mut Document, data: String) -> mut Text = "
    const r = #var(__self).createTextNode(#fun(String::as_js)(#var(data)));
    return #fun(Text::from_js)(r);
"

pub ext fun Document::create_cdata_section(__self: mut Document, data: String) -> mut CDATASection = "
    const r = #var(__self).createCDATASection(#fun(String::as_js)(#var(data)));
    return #fun(CDATASection::from_js)(r);
"

pub ext fun Document::create_comment(__self: mut Document, data: String) -> mut Comment = "
    const r = #var(__self).createComment(#fun(String::as_js)(#var(data)));
    return #fun(Comment::from_js)(r);
"

pub ext fun Document::create_processing_instruction(__self: mut Document, target: String, data: String) -> mut ProcessingInstruction = "
    const r = #var(__self).createProcessingInstruction(#fun(String::as_js)(#var(target)), #fun(String::as_js)(#var(data)));
    return #fun(ProcessingInstruction::from_js)(r);
"

pub ext fun Document::import_node(__self: mut Document, node: mut Node, options: JsValue) -> mut Node = "
    const r = #var(__self).importNode(#fun(Node::as_js)(#var(node)), #var(options));
    return #fun(Node::from_js)(r);
"

pub ext fun Document::adopt_node(__self: mut Document, node: mut Node) -> mut Node = "
    const r = #var(__self).adoptNode(#fun(Node::as_js)(#var(node)));
    return #fun(Node::from_js)(r);
"

pub ext fun Document::create_attribute(__self: mut Document, local_name: String) -> mut Attr = "
    const r = #var(__self).createAttribute(#fun(String::as_js)(#var(local_name)));
    return #fun(Attr::from_js)(r);
"

pub ext fun Document::create_attribute_ns(__self: mut Document, namespace: Option[String], qualified_name: String) -> mut Attr = "
    const r = #var(__self).createAttributeNS(#fun(Option::as_js[String])(#var(namespace)), #fun(String::as_js)(#var(qualified_name)));
    return #fun(Attr::from_js)(r);
"

pub ext fun Document::create_event(__self: mut Document, interface: String) -> mut Event = "
    const r = #var(__self).createEvent(#fun(String::as_js)(#var(interface)));
    return #fun(Event::from_js)(r);
"

pub ext fun Document::create_range(__self: mut Document) -> mut Range = "
    const r = #var(__self).createRange();
    return #fun(Range::from_js)(r);
"

pub ext fun Document::create_node_iterator(__self: mut Document, root: mut Node, what_to_show: Int, filter: Option[Fun(mut Node) -> Int]) -> mut NodeIterator = "
    const r = #var(__self).createNodeIterator(#fun(Node::as_js)(#var(root)), #fun(Int::as_js)(#var(what_to_show)), #fun(Option::as_js[Fun(mut Node) -> Int])(#var(filter)));
    return #fun(NodeIterator::from_js)(r);
"

pub ext fun Document::create_tree_walker(__self: mut Document, root: mut Node, what_to_show: Int, filter: Option[Fun(mut Node) -> Int]) -> mut TreeWalker = "
    const r = #var(__self).createTreeWalker(#fun(Node::as_js)(#var(root)), #fun(Int::as_js)(#var(what_to_show)), #fun(Option::as_js[Fun(mut Node) -> Int])(#var(filter)));
    return #fun(TreeWalker::from_js)(r);
"

pub ext fun Document::get_root_node(__self: mut Document, options: mut GetRootNodeOptions) -> mut Node = "
    const r = #var(__self).getRootNode(#fun(GetRootNodeOptions::as_js)(#var(options)));
    return #fun(Node::from_js)(r);
"

pub ext fun Document::has_child_nodes(__self: mut Document) -> Bool = "
    const r = #var(__self).hasChildNodes();
    return #fun(Bool::from_js)(r);
"

pub ext fun Document::normalize(__self: mut Document) -> Unit = "
    const r = #var(__self).normalize();
    return #fun(Unit::from_js)(r);
"

pub ext fun Document::clone_node(__self: mut Document, subtree: Bool) -> mut Node = "
    const r = #var(__self).cloneNode(#fun(Bool::as_js)(#var(subtree)));
    return #fun(Node::from_js)(r);
"

pub ext fun Document::is_equal_node(__self: mut Document, other_node: Option[mut Node]) -> Bool = "
    const r = #var(__self).isEqualNode(#fun(Option::as_js[mut Node])(#var(other_node)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Document::is_same_node(__self: mut Document, other_node: Option[mut Node]) -> Bool = "
    const r = #var(__self).isSameNode(#fun(Option::as_js[mut Node])(#var(other_node)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Document::compare_document_position(__self: mut Document, other: mut Node) -> Int = "
    const r = #var(__self).compareDocumentPosition(#fun(Node::as_js)(#var(other)));
    return #fun(Int::from_js)(r);
"

pub ext fun Document::contains(__self: mut Document, other: Option[mut Node]) -> Bool = "
    const r = #var(__self).contains(#fun(Option::as_js[mut Node])(#var(other)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Document::lookup_prefix(__self: mut Document, namespace: Option[String]) -> Option[String] = "
    const r = #var(__self).lookupPrefix(#fun(Option::as_js[String])(#var(namespace)));
    return #fun(Option::from_js[String])(r);
"

pub ext fun Document::lookup_namespace_uri(__self: mut Document, prefix: Option[String]) -> Option[String] = "
    const r = #var(__self).lookupNamespaceURI(#fun(Option::as_js[String])(#var(prefix)));
    return #fun(Option::from_js[String])(r);
"

pub ext fun Document::is_default_namespace(__self: mut Document, namespace: Option[String]) -> Bool = "
    const r = #var(__self).isDefaultNamespace(#fun(Option::as_js[String])(#var(namespace)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Document::insert_before(__self: mut Document, node: mut Node, child: Option[mut Node]) -> mut Node = "
    const r = #var(__self).insertBefore(#fun(Node::as_js)(#var(node)), #fun(Option::as_js[mut Node])(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun Document::append_child(__self: mut Document, node: mut Node) -> mut Node = "
    const r = #var(__self).appendChild(#fun(Node::as_js)(#var(node)));
    return #fun(Node::from_js)(r);
"

pub ext fun Document::replace_child(__self: mut Document, node: mut Node, child: mut Node) -> mut Node = "
    const r = #var(__self).replaceChild(#fun(Node::as_js)(#var(node)), #fun(Node::as_js)(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun Document::remove_child(__self: mut Document, child: mut Node) -> mut Node = "
    const r = #var(__self).removeChild(#fun(Node::as_js)(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun Document::add_event_listener(__self: mut Document, type: String, callback: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).addEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(callback)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun Document::remove_event_listener(__self: mut Document, type: String, callback: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).removeEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(callback)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun Document::dispatch_event(__self: mut Document, event: mut Event) -> Bool = "
    const r = #var(__self).dispatchEvent(#fun(Event::as_js)(#var(event)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Document::get_element_by_id(__self: mut Document, element_id: String) -> Option[mut Element] = "
    const r = #var(__self).getElementById(#fun(String::as_js)(#var(element_id)));
    return #fun(Option::from_js[mut Element])(r);
"

pub ext fun Document::prepend(__self: mut Document, ...nodes: List[JsValue]) -> Unit = "
    const r = #var(__self).prepend((#var(nodes)).map(v => v));
    return #fun(Unit::from_js)(r);
"

pub ext fun Document::append(__self: mut Document, ...nodes: List[JsValue]) -> Unit = "
    const r = #var(__self).append((#var(nodes)).map(v => v));
    return #fun(Unit::from_js)(r);
"

pub ext fun Document::replace_children(__self: mut Document, ...nodes: List[JsValue]) -> Unit = "
    const r = #var(__self).replaceChildren((#var(nodes)).map(v => v));
    return #fun(Unit::from_js)(r);
"

pub ext fun Document::move_before(__self: mut Document, node: mut Node, child: Option[mut Node]) -> Unit = "
    const r = #var(__self).moveBefore(#fun(Node::as_js)(#var(node)), #fun(Option::as_js[mut Node])(#var(child)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Document::query_selector(__self: mut Document, selectors: String) -> Option[mut Element] = "
    const r = #var(__self).querySelector(#fun(String::as_js)(#var(selectors)));
    return #fun(Option::from_js[mut Element])(r);
"

pub ext fun Document::query_selector_all(__self: mut Document, selectors: String) -> mut NodeList = "
    const r = #var(__self).querySelectorAll(#fun(String::as_js)(#var(selectors)));
    return #fun(NodeList::from_js)(r);
"

pub ext fun Document::create_expression(__self: mut Document, expression: String, resolver: Option[Fun(Option[String]) -> Option[String]]) -> mut XPathExpression = "
    const r = #var(__self).createExpression(#fun(String::as_js)(#var(expression)), #fun(Option::as_js[Fun(Option[String]) -> Option[String]])(#var(resolver)));
    return #fun(XPathExpression::from_js)(r);
"

pub ext fun Document::create_ns_resolver(__self: mut Document, node_resolver: mut Node) -> mut Node = "
    const r = #var(__self).createNSResolver(#fun(Node::as_js)(#var(node_resolver)));
    return #fun(Node::from_js)(r);
"

pub ext fun Document::evaluate(__self: mut Document, expression: String, context_node: mut Node, resolver: Option[Fun(Option[String]) -> Option[String]], type: Int, result: Option[mut XPathResult]) -> mut XPathResult = "
    const r = #var(__self).evaluate(#fun(String::as_js)(#var(expression)), #fun(Node::as_js)(#var(context_node)), #fun(Option::as_js[Fun(Option[String]) -> Option[String]])(#var(resolver)), #fun(Int::as_js)(#var(type)), #fun(Option::as_js[mut XPathResult])(#var(result)));
    return #fun(XPathResult::from_js)(r);
"

pub fun Document::as_js(self: Document) -> JsValue = JsValue::unsafe_from[Document](self)

pub fun Document::from_js(v: JsValue) -> mut Document = JsValue::unsafe_as[mut Document](v)

pub val Document::ELEMENT_NODE: Int = 1
pub val Document::ATTRIBUTE_NODE: Int = 2
pub val Document::TEXT_NODE: Int = 3
pub val Document::CDATA_SECTION_NODE: Int = 4
pub val Document::ENTITY_REFERENCE_NODE: Int = 5
pub val Document::ENTITY_NODE: Int = 6
pub val Document::PROCESSING_INSTRUCTION_NODE: Int = 7
pub val Document::COMMENT_NODE: Int = 8
pub val Document::DOCUMENT_NODE: Int = 9
pub val Document::DOCUMENT_TYPE_NODE: Int = 10
pub val Document::DOCUMENT_FRAGMENT_NODE: Int = 11
pub val Document::NOTATION_NODE: Int = 12
pub val Document::DOCUMENT_POSITION_DISCONNECTED: Int = 1
pub val Document::DOCUMENT_POSITION_PRECEDING: Int = 2
pub val Document::DOCUMENT_POSITION_FOLLOWING: Int = 4
pub val Document::DOCUMENT_POSITION_CONTAINS: Int = 8
pub val Document::DOCUMENT_POSITION_CONTAINED_BY: Int = 16
pub val Document::DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Int = 32

struct XMLDocument()

/// Converts a reference to 'XMLDocument' to a reference to 'Document'.
/// This does not involve manipulating the object or reference.
pub ext fun XMLDocument::as_document(self: XMLDocument) -> Document = "return #var(self);"

/// Converts a mutable reference to 'XMLDocument' to a mutable reference to 'Document'.
/// This does not involve manipulating the object or reference.
pub ext fun XMLDocument::as_mdocument(self: mut XMLDocument) -> mut Document = "return #var(self);"

/// Attempts to convert a reference to 'Document' to a reference to 'XMLDocument'.
/// The conversion may fail and panic if 'base' is not a reference to 'XMLDocument' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun XMLDocument::from_document(base: Document) -> XMLDocument = "
    if(#var(base) instanceof XMLDocument) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Document' to 'XMLDocument'!\");
"

/// Attempts to convert a mutable reference to 'Document' to a mutable reference to 'XMLDocument'.
/// The conversion may fail and panic if 'base' is not a reference to 'XMLDocument' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun XMLDocument::from_mdocument(base: mut Document) -> mut XMLDocument = "
    if(#var(base) instanceof XMLDocument) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Document' to 'XMLDocument'!\");
"

/// Converts a reference to 'XMLDocument' to a reference to 'Node'.
/// This does not involve manipulating the object or reference.
pub ext fun XMLDocument::as_node(self: XMLDocument) -> Node = "return #var(self);"

/// Converts a mutable reference to 'XMLDocument' to a mutable reference to 'Node'.
/// This does not involve manipulating the object or reference.
pub ext fun XMLDocument::as_mnode(self: mut XMLDocument) -> mut Node = "return #var(self);"

/// Attempts to convert a reference to 'Node' to a reference to 'XMLDocument'.
/// The conversion may fail and panic if 'base' is not a reference to 'XMLDocument' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun XMLDocument::from_node(base: Node) -> XMLDocument = "
    if(#var(base) instanceof XMLDocument) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Node' to 'XMLDocument'!\");
"

/// Attempts to convert a mutable reference to 'Node' to a mutable reference to 'XMLDocument'.
/// The conversion may fail and panic if 'base' is not a reference to 'XMLDocument' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun XMLDocument::from_mnode(base: mut Node) -> mut XMLDocument = "
    if(#var(base) instanceof XMLDocument) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Node' to 'XMLDocument'!\");
"

/// Converts a reference to 'XMLDocument' to a reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun XMLDocument::as_event_target(self: XMLDocument) -> EventTarget = "return #var(self);"

/// Converts a mutable reference to 'XMLDocument' to a mutable reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun XMLDocument::as_mevent_target(self: mut XMLDocument) -> mut EventTarget = "return #var(self);"

/// Attempts to convert a reference to 'EventTarget' to a reference to 'XMLDocument'.
/// The conversion may fail and panic if 'base' is not a reference to 'XMLDocument' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun XMLDocument::from_event_target(base: EventTarget) -> XMLDocument = "
    if(#var(base) instanceof XMLDocument) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'XMLDocument'!\");
"

/// Attempts to convert a mutable reference to 'EventTarget' to a mutable reference to 'XMLDocument'.
/// The conversion may fail and panic if 'base' is not a reference to 'XMLDocument' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun XMLDocument::from_mevent_target(base: mut EventTarget) -> mut XMLDocument = "
    if(#var(base) instanceof XMLDocument) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'XMLDocument'!\");
"

pub ext fun XMLDocument::implementation(self: XMLDocument) -> mut DOMImplementation
    = "return #fun(DOMImplementation::from_js)(#var(self).implementation);"

pub ext fun XMLDocument::url(self: XMLDocument) -> String
    = "return #fun(String::from_js)(#var(self).URL);"

pub ext fun XMLDocument::document_uri(self: XMLDocument) -> String
    = "return #fun(String::from_js)(#var(self).documentURI);"

pub ext fun XMLDocument::compat_mode(self: XMLDocument) -> String
    = "return #fun(String::from_js)(#var(self).compatMode);"

pub ext fun XMLDocument::character_set(self: XMLDocument) -> String
    = "return #fun(String::from_js)(#var(self).characterSet);"

pub ext fun XMLDocument::charset(self: XMLDocument) -> String
    = "return #fun(String::from_js)(#var(self).charset);"

pub ext fun XMLDocument::input_encoding(self: XMLDocument) -> String
    = "return #fun(String::from_js)(#var(self).inputEncoding);"

pub ext fun XMLDocument::content_type(self: XMLDocument) -> String
    = "return #fun(String::from_js)(#var(self).contentType);"

pub ext fun XMLDocument::doctype(self: XMLDocument) -> Option[mut DocumentType]
    = "return #fun(Option::from_js[mut DocumentType])(#var(self).doctype);"

pub ext fun XMLDocument::document_element(self: XMLDocument) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).documentElement);"

pub ext fun XMLDocument::node_type(self: XMLDocument) -> Int
    = "return #fun(Int::from_js)(#var(self).nodeType);"

pub ext fun XMLDocument::node_name(self: XMLDocument) -> String
    = "return #fun(String::from_js)(#var(self).nodeName);"

pub ext fun XMLDocument::base_uri(self: XMLDocument) -> String
    = "return #fun(String::from_js)(#var(self).baseURI);"

pub ext fun XMLDocument::is_connected(self: XMLDocument) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isConnected);"

pub ext fun XMLDocument::owner_document(self: XMLDocument) -> Option[mut Document]
    = "return #fun(Option::from_js[mut Document])(#var(self).ownerDocument);"

pub ext fun XMLDocument::parent_node(self: XMLDocument) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).parentNode);"

pub ext fun XMLDocument::parent_element(self: XMLDocument) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).parentElement);"

pub ext fun XMLDocument::child_nodes(self: XMLDocument) -> mut NodeList
    = "return #fun(NodeList::from_js)(#var(self).childNodes);"

pub ext fun XMLDocument::first_child(self: XMLDocument) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).firstChild);"

pub ext fun XMLDocument::last_child(self: XMLDocument) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).lastChild);"

pub ext fun XMLDocument::previous_sibling(self: XMLDocument) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).previousSibling);"

pub ext fun XMLDocument::next_sibling(self: XMLDocument) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).nextSibling);"

pub ext fun XMLDocument::node_value(self: XMLDocument) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).nodeValue);"

pub ext fun XMLDocument::set_node_value(self: mut XMLDocument, value: Option[String])
    = "#var(self).nodeValue = #fun(Option::as_js[String])(#var(value));"

pub ext fun XMLDocument::text_content(self: XMLDocument) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).textContent);"

pub ext fun XMLDocument::set_text_content(self: mut XMLDocument, value: Option[String])
    = "#var(self).textContent = #fun(Option::as_js[String])(#var(value));"

pub ext fun XMLDocument::get_elements_by_tag_name(__self: mut XMLDocument, qualified_name: String) -> mut HTMLCollection = "
    const r = #var(__self).getElementsByTagName(#fun(String::as_js)(#var(qualified_name)));
    return #fun(HTMLCollection::from_js)(r);
"

pub ext fun XMLDocument::get_elements_by_tag_name_ns(__self: mut XMLDocument, namespace: Option[String], local_name: String) -> mut HTMLCollection = "
    const r = #var(__self).getElementsByTagNameNS(#fun(Option::as_js[String])(#var(namespace)), #fun(String::as_js)(#var(local_name)));
    return #fun(HTMLCollection::from_js)(r);
"

pub ext fun XMLDocument::get_elements_by_class_name(__self: mut XMLDocument, class_names: String) -> mut HTMLCollection = "
    const r = #var(__self).getElementsByClassName(#fun(String::as_js)(#var(class_names)));
    return #fun(HTMLCollection::from_js)(r);
"

pub ext fun XMLDocument::create_element(__self: mut XMLDocument, local_name: String, options: JsValue) -> mut Element = "
    const r = #var(__self).createElement(#fun(String::as_js)(#var(local_name)), #var(options));
    return #fun(Element::from_js)(r);
"

pub ext fun XMLDocument::create_element_ns(__self: mut XMLDocument, namespace: Option[String], qualified_name: String, options: JsValue) -> mut Element = "
    const r = #var(__self).createElementNS(#fun(Option::as_js[String])(#var(namespace)), #fun(String::as_js)(#var(qualified_name)), #var(options));
    return #fun(Element::from_js)(r);
"

pub ext fun XMLDocument::create_document_fragment(__self: mut XMLDocument) -> mut DocumentFragment = "
    const r = #var(__self).createDocumentFragment();
    return #fun(DocumentFragment::from_js)(r);
"

pub ext fun XMLDocument::create_text_node(__self: mut XMLDocument, data: String) -> mut Text = "
    const r = #var(__self).createTextNode(#fun(String::as_js)(#var(data)));
    return #fun(Text::from_js)(r);
"

pub ext fun XMLDocument::create_cdata_section(__self: mut XMLDocument, data: String) -> mut CDATASection = "
    const r = #var(__self).createCDATASection(#fun(String::as_js)(#var(data)));
    return #fun(CDATASection::from_js)(r);
"

pub ext fun XMLDocument::create_comment(__self: mut XMLDocument, data: String) -> mut Comment = "
    const r = #var(__self).createComment(#fun(String::as_js)(#var(data)));
    return #fun(Comment::from_js)(r);
"

pub ext fun XMLDocument::create_processing_instruction(__self: mut XMLDocument, target: String, data: String) -> mut ProcessingInstruction = "
    const r = #var(__self).createProcessingInstruction(#fun(String::as_js)(#var(target)), #fun(String::as_js)(#var(data)));
    return #fun(ProcessingInstruction::from_js)(r);
"

pub ext fun XMLDocument::import_node(__self: mut XMLDocument, node: mut Node, options: JsValue) -> mut Node = "
    const r = #var(__self).importNode(#fun(Node::as_js)(#var(node)), #var(options));
    return #fun(Node::from_js)(r);
"

pub ext fun XMLDocument::adopt_node(__self: mut XMLDocument, node: mut Node) -> mut Node = "
    const r = #var(__self).adoptNode(#fun(Node::as_js)(#var(node)));
    return #fun(Node::from_js)(r);
"

pub ext fun XMLDocument::create_attribute(__self: mut XMLDocument, local_name: String) -> mut Attr = "
    const r = #var(__self).createAttribute(#fun(String::as_js)(#var(local_name)));
    return #fun(Attr::from_js)(r);
"

pub ext fun XMLDocument::create_attribute_ns(__self: mut XMLDocument, namespace: Option[String], qualified_name: String) -> mut Attr = "
    const r = #var(__self).createAttributeNS(#fun(Option::as_js[String])(#var(namespace)), #fun(String::as_js)(#var(qualified_name)));
    return #fun(Attr::from_js)(r);
"

pub ext fun XMLDocument::create_event(__self: mut XMLDocument, interface: String) -> mut Event = "
    const r = #var(__self).createEvent(#fun(String::as_js)(#var(interface)));
    return #fun(Event::from_js)(r);
"

pub ext fun XMLDocument::create_range(__self: mut XMLDocument) -> mut Range = "
    const r = #var(__self).createRange();
    return #fun(Range::from_js)(r);
"

pub ext fun XMLDocument::create_node_iterator(__self: mut XMLDocument, root: mut Node, what_to_show: Int, filter: Option[Fun(mut Node) -> Int]) -> mut NodeIterator = "
    const r = #var(__self).createNodeIterator(#fun(Node::as_js)(#var(root)), #fun(Int::as_js)(#var(what_to_show)), #fun(Option::as_js[Fun(mut Node) -> Int])(#var(filter)));
    return #fun(NodeIterator::from_js)(r);
"

pub ext fun XMLDocument::create_tree_walker(__self: mut XMLDocument, root: mut Node, what_to_show: Int, filter: Option[Fun(mut Node) -> Int]) -> mut TreeWalker = "
    const r = #var(__self).createTreeWalker(#fun(Node::as_js)(#var(root)), #fun(Int::as_js)(#var(what_to_show)), #fun(Option::as_js[Fun(mut Node) -> Int])(#var(filter)));
    return #fun(TreeWalker::from_js)(r);
"

pub ext fun XMLDocument::get_root_node(__self: mut XMLDocument, options: mut GetRootNodeOptions) -> mut Node = "
    const r = #var(__self).getRootNode(#fun(GetRootNodeOptions::as_js)(#var(options)));
    return #fun(Node::from_js)(r);
"

pub ext fun XMLDocument::has_child_nodes(__self: mut XMLDocument) -> Bool = "
    const r = #var(__self).hasChildNodes();
    return #fun(Bool::from_js)(r);
"

pub ext fun XMLDocument::normalize(__self: mut XMLDocument) -> Unit = "
    const r = #var(__self).normalize();
    return #fun(Unit::from_js)(r);
"

pub ext fun XMLDocument::clone_node(__self: mut XMLDocument, subtree: Bool) -> mut Node = "
    const r = #var(__self).cloneNode(#fun(Bool::as_js)(#var(subtree)));
    return #fun(Node::from_js)(r);
"

pub ext fun XMLDocument::is_equal_node(__self: mut XMLDocument, other_node: Option[mut Node]) -> Bool = "
    const r = #var(__self).isEqualNode(#fun(Option::as_js[mut Node])(#var(other_node)));
    return #fun(Bool::from_js)(r);
"

pub ext fun XMLDocument::is_same_node(__self: mut XMLDocument, other_node: Option[mut Node]) -> Bool = "
    const r = #var(__self).isSameNode(#fun(Option::as_js[mut Node])(#var(other_node)));
    return #fun(Bool::from_js)(r);
"

pub ext fun XMLDocument::compare_document_position(__self: mut XMLDocument, other: mut Node) -> Int = "
    const r = #var(__self).compareDocumentPosition(#fun(Node::as_js)(#var(other)));
    return #fun(Int::from_js)(r);
"

pub ext fun XMLDocument::contains(__self: mut XMLDocument, other: Option[mut Node]) -> Bool = "
    const r = #var(__self).contains(#fun(Option::as_js[mut Node])(#var(other)));
    return #fun(Bool::from_js)(r);
"

pub ext fun XMLDocument::lookup_prefix(__self: mut XMLDocument, namespace: Option[String]) -> Option[String] = "
    const r = #var(__self).lookupPrefix(#fun(Option::as_js[String])(#var(namespace)));
    return #fun(Option::from_js[String])(r);
"

pub ext fun XMLDocument::lookup_namespace_uri(__self: mut XMLDocument, prefix: Option[String]) -> Option[String] = "
    const r = #var(__self).lookupNamespaceURI(#fun(Option::as_js[String])(#var(prefix)));
    return #fun(Option::from_js[String])(r);
"

pub ext fun XMLDocument::is_default_namespace(__self: mut XMLDocument, namespace: Option[String]) -> Bool = "
    const r = #var(__self).isDefaultNamespace(#fun(Option::as_js[String])(#var(namespace)));
    return #fun(Bool::from_js)(r);
"

pub ext fun XMLDocument::insert_before(__self: mut XMLDocument, node: mut Node, child: Option[mut Node]) -> mut Node = "
    const r = #var(__self).insertBefore(#fun(Node::as_js)(#var(node)), #fun(Option::as_js[mut Node])(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun XMLDocument::append_child(__self: mut XMLDocument, node: mut Node) -> mut Node = "
    const r = #var(__self).appendChild(#fun(Node::as_js)(#var(node)));
    return #fun(Node::from_js)(r);
"

pub ext fun XMLDocument::replace_child(__self: mut XMLDocument, node: mut Node, child: mut Node) -> mut Node = "
    const r = #var(__self).replaceChild(#fun(Node::as_js)(#var(node)), #fun(Node::as_js)(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun XMLDocument::remove_child(__self: mut XMLDocument, child: mut Node) -> mut Node = "
    const r = #var(__self).removeChild(#fun(Node::as_js)(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun XMLDocument::add_event_listener(__self: mut XMLDocument, type: String, callback: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).addEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(callback)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun XMLDocument::remove_event_listener(__self: mut XMLDocument, type: String, callback: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).removeEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(callback)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun XMLDocument::dispatch_event(__self: mut XMLDocument, event: mut Event) -> Bool = "
    const r = #var(__self).dispatchEvent(#fun(Event::as_js)(#var(event)));
    return #fun(Bool::from_js)(r);
"

pub fun XMLDocument::as_js(self: XMLDocument) -> JsValue = JsValue::unsafe_from[XMLDocument](self)

pub fun XMLDocument::from_js(v: JsValue) -> mut XMLDocument = JsValue::unsafe_as[mut XMLDocument](v)

pub val XMLDocument::ELEMENT_NODE: Int = 1
pub val XMLDocument::ATTRIBUTE_NODE: Int = 2
pub val XMLDocument::TEXT_NODE: Int = 3
pub val XMLDocument::CDATA_SECTION_NODE: Int = 4
pub val XMLDocument::ENTITY_REFERENCE_NODE: Int = 5
pub val XMLDocument::ENTITY_NODE: Int = 6
pub val XMLDocument::PROCESSING_INSTRUCTION_NODE: Int = 7
pub val XMLDocument::COMMENT_NODE: Int = 8
pub val XMLDocument::DOCUMENT_NODE: Int = 9
pub val XMLDocument::DOCUMENT_TYPE_NODE: Int = 10
pub val XMLDocument::DOCUMENT_FRAGMENT_NODE: Int = 11
pub val XMLDocument::NOTATION_NODE: Int = 12
pub val XMLDocument::DOCUMENT_POSITION_DISCONNECTED: Int = 1
pub val XMLDocument::DOCUMENT_POSITION_PRECEDING: Int = 2
pub val XMLDocument::DOCUMENT_POSITION_FOLLOWING: Int = 4
pub val XMLDocument::DOCUMENT_POSITION_CONTAINS: Int = 8
pub val XMLDocument::DOCUMENT_POSITION_CONTAINED_BY: Int = 16
pub val XMLDocument::DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Int = 32

pub struct ElementCreationOptions(
    custom_element_registry: Option[JsValue],
    is: Option[String]
)

pub fun ElementCreationOptions::default() -> mut ElementCreationOptions
    = ElementCreationOptions(Option::None, Option::None)

pub ext fun ElementCreationOptions::from_js(value: JsValue) -> mut ElementCreationOptions = "
    const r = {};
    r.custom_element_registry = #fun(Option::from_js[JsValue])(#var(value).customElementRegistry);
    r.is = #fun(Option::from_js[String])(#var(value).is);
    return r;
"

pub ext fun ElementCreationOptions::as_js(self: ElementCreationOptions) -> JsValue = "
    const r = {};
    r.customElementRegistry = #fun(Option::as_js[JsValue])(#var(self).custom_element_registry);
    r.is = #fun(Option::as_js[String])(#var(self).is);
    return r;
"

pub struct ImportNodeOptions(
    custom_element_registry: Option[JsValue],
    self_only: Option[Bool]
)

pub fun ImportNodeOptions::default() -> mut ImportNodeOptions
    = ImportNodeOptions(Option::None, Option::Some(false))

pub ext fun ImportNodeOptions::from_js(value: JsValue) -> mut ImportNodeOptions = "
    const r = {};
    r.custom_element_registry = #fun(Option::from_js[JsValue])(#var(value).customElementRegistry);
    r.self_only = #fun(Option::from_js[Bool])(#var(value).selfOnly);
    return r;
"

pub ext fun ImportNodeOptions::as_js(self: ImportNodeOptions) -> JsValue = "
    const r = {};
    r.customElementRegistry = #fun(Option::as_js[JsValue])(#var(self).custom_element_registry);
    r.selfOnly = #fun(Option::as_js[Bool])(#var(self).self_only);
    return r;
"

struct DOMImplementation()

pub ext fun DOMImplementation::create_document_type(__self: mut DOMImplementation, name: String, public_id: String, system_id: String) -> mut DocumentType = "
    const r = #var(__self).createDocumentType(#fun(String::as_js)(#var(name)), #fun(String::as_js)(#var(public_id)), #fun(String::as_js)(#var(system_id)));
    return #fun(DocumentType::from_js)(r);
"

pub ext fun DOMImplementation::create_document(__self: mut DOMImplementation, namespace: Option[String], qualified_name: String, doctype: Option[mut DocumentType]) -> mut XMLDocument = "
    const r = #var(__self).createDocument(#fun(Option::as_js[String])(#var(namespace)), #fun(String::as_js)(#var(qualified_name)), #fun(Option::as_js[mut DocumentType])(#var(doctype)));
    return #fun(XMLDocument::from_js)(r);
"

pub ext fun DOMImplementation::create_html_document(__self: mut DOMImplementation, title: String) -> mut Document = "
    const r = #var(__self).createHTMLDocument(#fun(String::as_js)(#var(title)));
    return #fun(Document::from_js)(r);
"

pub ext fun DOMImplementation::has_feature(__self: mut DOMImplementation) -> Bool = "
    const r = #var(__self).hasFeature();
    return #fun(Bool::from_js)(r);
"

pub fun DOMImplementation::as_js(self: DOMImplementation) -> JsValue = JsValue::unsafe_from[DOMImplementation](self)

pub fun DOMImplementation::from_js(v: JsValue) -> mut DOMImplementation = JsValue::unsafe_as[mut DOMImplementation](v)

struct DocumentType()

/// Converts a reference to 'DocumentType' to a reference to 'Node'.
/// This does not involve manipulating the object or reference.
pub ext fun DocumentType::as_node(self: DocumentType) -> Node = "return #var(self);"

/// Converts a mutable reference to 'DocumentType' to a mutable reference to 'Node'.
/// This does not involve manipulating the object or reference.
pub ext fun DocumentType::as_mnode(self: mut DocumentType) -> mut Node = "return #var(self);"

/// Attempts to convert a reference to 'Node' to a reference to 'DocumentType'.
/// The conversion may fail and panic if 'base' is not a reference to 'DocumentType' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun DocumentType::from_node(base: Node) -> DocumentType = "
    if(#var(base) instanceof DocumentType) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Node' to 'DocumentType'!\");
"

/// Attempts to convert a mutable reference to 'Node' to a mutable reference to 'DocumentType'.
/// The conversion may fail and panic if 'base' is not a reference to 'DocumentType' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun DocumentType::from_mnode(base: mut Node) -> mut DocumentType = "
    if(#var(base) instanceof DocumentType) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Node' to 'DocumentType'!\");
"

/// Converts a reference to 'DocumentType' to a reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun DocumentType::as_event_target(self: DocumentType) -> EventTarget = "return #var(self);"

/// Converts a mutable reference to 'DocumentType' to a mutable reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun DocumentType::as_mevent_target(self: mut DocumentType) -> mut EventTarget = "return #var(self);"

/// Attempts to convert a reference to 'EventTarget' to a reference to 'DocumentType'.
/// The conversion may fail and panic if 'base' is not a reference to 'DocumentType' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun DocumentType::from_event_target(base: EventTarget) -> DocumentType = "
    if(#var(base) instanceof DocumentType) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'DocumentType'!\");
"

/// Attempts to convert a mutable reference to 'EventTarget' to a mutable reference to 'DocumentType'.
/// The conversion may fail and panic if 'base' is not a reference to 'DocumentType' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun DocumentType::from_mevent_target(base: mut EventTarget) -> mut DocumentType = "
    if(#var(base) instanceof DocumentType) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'DocumentType'!\");
"

pub ext fun DocumentType::name(self: DocumentType) -> String
    = "return #fun(String::from_js)(#var(self).name);"

pub ext fun DocumentType::public_id(self: DocumentType) -> String
    = "return #fun(String::from_js)(#var(self).publicId);"

pub ext fun DocumentType::system_id(self: DocumentType) -> String
    = "return #fun(String::from_js)(#var(self).systemId);"

pub ext fun DocumentType::node_type(self: DocumentType) -> Int
    = "return #fun(Int::from_js)(#var(self).nodeType);"

pub ext fun DocumentType::node_name(self: DocumentType) -> String
    = "return #fun(String::from_js)(#var(self).nodeName);"

pub ext fun DocumentType::base_uri(self: DocumentType) -> String
    = "return #fun(String::from_js)(#var(self).baseURI);"

pub ext fun DocumentType::is_connected(self: DocumentType) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isConnected);"

pub ext fun DocumentType::owner_document(self: DocumentType) -> Option[mut Document]
    = "return #fun(Option::from_js[mut Document])(#var(self).ownerDocument);"

pub ext fun DocumentType::parent_node(self: DocumentType) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).parentNode);"

pub ext fun DocumentType::parent_element(self: DocumentType) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).parentElement);"

pub ext fun DocumentType::child_nodes(self: DocumentType) -> mut NodeList
    = "return #fun(NodeList::from_js)(#var(self).childNodes);"

pub ext fun DocumentType::first_child(self: DocumentType) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).firstChild);"

pub ext fun DocumentType::last_child(self: DocumentType) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).lastChild);"

pub ext fun DocumentType::previous_sibling(self: DocumentType) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).previousSibling);"

pub ext fun DocumentType::next_sibling(self: DocumentType) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).nextSibling);"

pub ext fun DocumentType::node_value(self: DocumentType) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).nodeValue);"

pub ext fun DocumentType::set_node_value(self: mut DocumentType, value: Option[String])
    = "#var(self).nodeValue = #fun(Option::as_js[String])(#var(value));"

pub ext fun DocumentType::text_content(self: DocumentType) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).textContent);"

pub ext fun DocumentType::set_text_content(self: mut DocumentType, value: Option[String])
    = "#var(self).textContent = #fun(Option::as_js[String])(#var(value));"

pub ext fun DocumentType::get_root_node(__self: mut DocumentType, options: mut GetRootNodeOptions) -> mut Node = "
    const r = #var(__self).getRootNode(#fun(GetRootNodeOptions::as_js)(#var(options)));
    return #fun(Node::from_js)(r);
"

pub ext fun DocumentType::has_child_nodes(__self: mut DocumentType) -> Bool = "
    const r = #var(__self).hasChildNodes();
    return #fun(Bool::from_js)(r);
"

pub ext fun DocumentType::normalize(__self: mut DocumentType) -> Unit = "
    const r = #var(__self).normalize();
    return #fun(Unit::from_js)(r);
"

pub ext fun DocumentType::clone_node(__self: mut DocumentType, subtree: Bool) -> mut Node = "
    const r = #var(__self).cloneNode(#fun(Bool::as_js)(#var(subtree)));
    return #fun(Node::from_js)(r);
"

pub ext fun DocumentType::is_equal_node(__self: mut DocumentType, other_node: Option[mut Node]) -> Bool = "
    const r = #var(__self).isEqualNode(#fun(Option::as_js[mut Node])(#var(other_node)));
    return #fun(Bool::from_js)(r);
"

pub ext fun DocumentType::is_same_node(__self: mut DocumentType, other_node: Option[mut Node]) -> Bool = "
    const r = #var(__self).isSameNode(#fun(Option::as_js[mut Node])(#var(other_node)));
    return #fun(Bool::from_js)(r);
"

pub ext fun DocumentType::compare_document_position(__self: mut DocumentType, other: mut Node) -> Int = "
    const r = #var(__self).compareDocumentPosition(#fun(Node::as_js)(#var(other)));
    return #fun(Int::from_js)(r);
"

pub ext fun DocumentType::contains(__self: mut DocumentType, other: Option[mut Node]) -> Bool = "
    const r = #var(__self).contains(#fun(Option::as_js[mut Node])(#var(other)));
    return #fun(Bool::from_js)(r);
"

pub ext fun DocumentType::lookup_prefix(__self: mut DocumentType, namespace: Option[String]) -> Option[String] = "
    const r = #var(__self).lookupPrefix(#fun(Option::as_js[String])(#var(namespace)));
    return #fun(Option::from_js[String])(r);
"

pub ext fun DocumentType::lookup_namespace_uri(__self: mut DocumentType, prefix: Option[String]) -> Option[String] = "
    const r = #var(__self).lookupNamespaceURI(#fun(Option::as_js[String])(#var(prefix)));
    return #fun(Option::from_js[String])(r);
"

pub ext fun DocumentType::is_default_namespace(__self: mut DocumentType, namespace: Option[String]) -> Bool = "
    const r = #var(__self).isDefaultNamespace(#fun(Option::as_js[String])(#var(namespace)));
    return #fun(Bool::from_js)(r);
"

pub ext fun DocumentType::insert_before(__self: mut DocumentType, node: mut Node, child: Option[mut Node]) -> mut Node = "
    const r = #var(__self).insertBefore(#fun(Node::as_js)(#var(node)), #fun(Option::as_js[mut Node])(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun DocumentType::append_child(__self: mut DocumentType, node: mut Node) -> mut Node = "
    const r = #var(__self).appendChild(#fun(Node::as_js)(#var(node)));
    return #fun(Node::from_js)(r);
"

pub ext fun DocumentType::replace_child(__self: mut DocumentType, node: mut Node, child: mut Node) -> mut Node = "
    const r = #var(__self).replaceChild(#fun(Node::as_js)(#var(node)), #fun(Node::as_js)(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun DocumentType::remove_child(__self: mut DocumentType, child: mut Node) -> mut Node = "
    const r = #var(__self).removeChild(#fun(Node::as_js)(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun DocumentType::add_event_listener(__self: mut DocumentType, type: String, callback: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).addEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(callback)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun DocumentType::remove_event_listener(__self: mut DocumentType, type: String, callback: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).removeEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(callback)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun DocumentType::dispatch_event(__self: mut DocumentType, event: mut Event) -> Bool = "
    const r = #var(__self).dispatchEvent(#fun(Event::as_js)(#var(event)));
    return #fun(Bool::from_js)(r);
"

pub ext fun DocumentType::before(__self: mut DocumentType, ...nodes: List[JsValue]) -> Unit = "
    const r = #var(__self).before((#var(nodes)).map(v => v));
    return #fun(Unit::from_js)(r);
"

pub ext fun DocumentType::after(__self: mut DocumentType, ...nodes: List[JsValue]) -> Unit = "
    const r = #var(__self).after((#var(nodes)).map(v => v));
    return #fun(Unit::from_js)(r);
"

pub ext fun DocumentType::replace_with(__self: mut DocumentType, ...nodes: List[JsValue]) -> Unit = "
    const r = #var(__self).replaceWith((#var(nodes)).map(v => v));
    return #fun(Unit::from_js)(r);
"

pub ext fun DocumentType::remove(__self: mut DocumentType) -> Unit = "
    const r = #var(__self).remove();
    return #fun(Unit::from_js)(r);
"

pub fun DocumentType::as_js(self: DocumentType) -> JsValue = JsValue::unsafe_from[DocumentType](self)

pub fun DocumentType::from_js(v: JsValue) -> mut DocumentType = JsValue::unsafe_as[mut DocumentType](v)

pub val DocumentType::ELEMENT_NODE: Int = 1
pub val DocumentType::ATTRIBUTE_NODE: Int = 2
pub val DocumentType::TEXT_NODE: Int = 3
pub val DocumentType::CDATA_SECTION_NODE: Int = 4
pub val DocumentType::ENTITY_REFERENCE_NODE: Int = 5
pub val DocumentType::ENTITY_NODE: Int = 6
pub val DocumentType::PROCESSING_INSTRUCTION_NODE: Int = 7
pub val DocumentType::COMMENT_NODE: Int = 8
pub val DocumentType::DOCUMENT_NODE: Int = 9
pub val DocumentType::DOCUMENT_TYPE_NODE: Int = 10
pub val DocumentType::DOCUMENT_FRAGMENT_NODE: Int = 11
pub val DocumentType::NOTATION_NODE: Int = 12
pub val DocumentType::DOCUMENT_POSITION_DISCONNECTED: Int = 1
pub val DocumentType::DOCUMENT_POSITION_PRECEDING: Int = 2
pub val DocumentType::DOCUMENT_POSITION_FOLLOWING: Int = 4
pub val DocumentType::DOCUMENT_POSITION_CONTAINS: Int = 8
pub val DocumentType::DOCUMENT_POSITION_CONTAINED_BY: Int = 16
pub val DocumentType::DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Int = 32

struct DocumentFragment()

/// Converts a reference to 'DocumentFragment' to a reference to 'Node'.
/// This does not involve manipulating the object or reference.
pub ext fun DocumentFragment::as_node(self: DocumentFragment) -> Node = "return #var(self);"

/// Converts a mutable reference to 'DocumentFragment' to a mutable reference to 'Node'.
/// This does not involve manipulating the object or reference.
pub ext fun DocumentFragment::as_mnode(self: mut DocumentFragment) -> mut Node = "return #var(self);"

/// Attempts to convert a reference to 'Node' to a reference to 'DocumentFragment'.
/// The conversion may fail and panic if 'base' is not a reference to 'DocumentFragment' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun DocumentFragment::from_node(base: Node) -> DocumentFragment = "
    if(#var(base) instanceof DocumentFragment) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Node' to 'DocumentFragment'!\");
"

/// Attempts to convert a mutable reference to 'Node' to a mutable reference to 'DocumentFragment'.
/// The conversion may fail and panic if 'base' is not a reference to 'DocumentFragment' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun DocumentFragment::from_mnode(base: mut Node) -> mut DocumentFragment = "
    if(#var(base) instanceof DocumentFragment) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Node' to 'DocumentFragment'!\");
"

/// Converts a reference to 'DocumentFragment' to a reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun DocumentFragment::as_event_target(self: DocumentFragment) -> EventTarget = "return #var(self);"

/// Converts a mutable reference to 'DocumentFragment' to a mutable reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun DocumentFragment::as_mevent_target(self: mut DocumentFragment) -> mut EventTarget = "return #var(self);"

/// Attempts to convert a reference to 'EventTarget' to a reference to 'DocumentFragment'.
/// The conversion may fail and panic if 'base' is not a reference to 'DocumentFragment' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun DocumentFragment::from_event_target(base: EventTarget) -> DocumentFragment = "
    if(#var(base) instanceof DocumentFragment) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'DocumentFragment'!\");
"

/// Attempts to convert a mutable reference to 'EventTarget' to a mutable reference to 'DocumentFragment'.
/// The conversion may fail and panic if 'base' is not a reference to 'DocumentFragment' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun DocumentFragment::from_mevent_target(base: mut EventTarget) -> mut DocumentFragment = "
    if(#var(base) instanceof DocumentFragment) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'DocumentFragment'!\");
"

pub ext fun DocumentFragment::new() -> mut DocumentFragment
    = "new DocumentFragment();"

pub ext fun DocumentFragment::node_type(self: DocumentFragment) -> Int
    = "return #fun(Int::from_js)(#var(self).nodeType);"

pub ext fun DocumentFragment::node_name(self: DocumentFragment) -> String
    = "return #fun(String::from_js)(#var(self).nodeName);"

pub ext fun DocumentFragment::base_uri(self: DocumentFragment) -> String
    = "return #fun(String::from_js)(#var(self).baseURI);"

pub ext fun DocumentFragment::is_connected(self: DocumentFragment) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isConnected);"

pub ext fun DocumentFragment::owner_document(self: DocumentFragment) -> Option[mut Document]
    = "return #fun(Option::from_js[mut Document])(#var(self).ownerDocument);"

pub ext fun DocumentFragment::parent_node(self: DocumentFragment) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).parentNode);"

pub ext fun DocumentFragment::parent_element(self: DocumentFragment) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).parentElement);"

pub ext fun DocumentFragment::child_nodes(self: DocumentFragment) -> mut NodeList
    = "return #fun(NodeList::from_js)(#var(self).childNodes);"

pub ext fun DocumentFragment::first_child(self: DocumentFragment) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).firstChild);"

pub ext fun DocumentFragment::last_child(self: DocumentFragment) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).lastChild);"

pub ext fun DocumentFragment::previous_sibling(self: DocumentFragment) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).previousSibling);"

pub ext fun DocumentFragment::next_sibling(self: DocumentFragment) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).nextSibling);"

pub ext fun DocumentFragment::node_value(self: DocumentFragment) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).nodeValue);"

pub ext fun DocumentFragment::set_node_value(self: mut DocumentFragment, value: Option[String])
    = "#var(self).nodeValue = #fun(Option::as_js[String])(#var(value));"

pub ext fun DocumentFragment::text_content(self: DocumentFragment) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).textContent);"

pub ext fun DocumentFragment::set_text_content(self: mut DocumentFragment, value: Option[String])
    = "#var(self).textContent = #fun(Option::as_js[String])(#var(value));"

pub ext fun DocumentFragment::children(self: DocumentFragment) -> mut HTMLCollection
    = "return #fun(HTMLCollection::from_js)(#var(self).children);"

pub ext fun DocumentFragment::first_element_child(self: DocumentFragment) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).firstElementChild);"

pub ext fun DocumentFragment::last_element_child(self: DocumentFragment) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).lastElementChild);"

pub ext fun DocumentFragment::child_element_count(self: DocumentFragment) -> Int
    = "return #fun(Int::from_js)(#var(self).childElementCount);"

pub ext fun DocumentFragment::get_root_node(__self: mut DocumentFragment, options: mut GetRootNodeOptions) -> mut Node = "
    const r = #var(__self).getRootNode(#fun(GetRootNodeOptions::as_js)(#var(options)));
    return #fun(Node::from_js)(r);
"

pub ext fun DocumentFragment::has_child_nodes(__self: mut DocumentFragment) -> Bool = "
    const r = #var(__self).hasChildNodes();
    return #fun(Bool::from_js)(r);
"

pub ext fun DocumentFragment::normalize(__self: mut DocumentFragment) -> Unit = "
    const r = #var(__self).normalize();
    return #fun(Unit::from_js)(r);
"

pub ext fun DocumentFragment::clone_node(__self: mut DocumentFragment, subtree: Bool) -> mut Node = "
    const r = #var(__self).cloneNode(#fun(Bool::as_js)(#var(subtree)));
    return #fun(Node::from_js)(r);
"

pub ext fun DocumentFragment::is_equal_node(__self: mut DocumentFragment, other_node: Option[mut Node]) -> Bool = "
    const r = #var(__self).isEqualNode(#fun(Option::as_js[mut Node])(#var(other_node)));
    return #fun(Bool::from_js)(r);
"

pub ext fun DocumentFragment::is_same_node(__self: mut DocumentFragment, other_node: Option[mut Node]) -> Bool = "
    const r = #var(__self).isSameNode(#fun(Option::as_js[mut Node])(#var(other_node)));
    return #fun(Bool::from_js)(r);
"

pub ext fun DocumentFragment::compare_document_position(__self: mut DocumentFragment, other: mut Node) -> Int = "
    const r = #var(__self).compareDocumentPosition(#fun(Node::as_js)(#var(other)));
    return #fun(Int::from_js)(r);
"

pub ext fun DocumentFragment::contains(__self: mut DocumentFragment, other: Option[mut Node]) -> Bool = "
    const r = #var(__self).contains(#fun(Option::as_js[mut Node])(#var(other)));
    return #fun(Bool::from_js)(r);
"

pub ext fun DocumentFragment::lookup_prefix(__self: mut DocumentFragment, namespace: Option[String]) -> Option[String] = "
    const r = #var(__self).lookupPrefix(#fun(Option::as_js[String])(#var(namespace)));
    return #fun(Option::from_js[String])(r);
"

pub ext fun DocumentFragment::lookup_namespace_uri(__self: mut DocumentFragment, prefix: Option[String]) -> Option[String] = "
    const r = #var(__self).lookupNamespaceURI(#fun(Option::as_js[String])(#var(prefix)));
    return #fun(Option::from_js[String])(r);
"

pub ext fun DocumentFragment::is_default_namespace(__self: mut DocumentFragment, namespace: Option[String]) -> Bool = "
    const r = #var(__self).isDefaultNamespace(#fun(Option::as_js[String])(#var(namespace)));
    return #fun(Bool::from_js)(r);
"

pub ext fun DocumentFragment::insert_before(__self: mut DocumentFragment, node: mut Node, child: Option[mut Node]) -> mut Node = "
    const r = #var(__self).insertBefore(#fun(Node::as_js)(#var(node)), #fun(Option::as_js[mut Node])(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun DocumentFragment::append_child(__self: mut DocumentFragment, node: mut Node) -> mut Node = "
    const r = #var(__self).appendChild(#fun(Node::as_js)(#var(node)));
    return #fun(Node::from_js)(r);
"

pub ext fun DocumentFragment::replace_child(__self: mut DocumentFragment, node: mut Node, child: mut Node) -> mut Node = "
    const r = #var(__self).replaceChild(#fun(Node::as_js)(#var(node)), #fun(Node::as_js)(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun DocumentFragment::remove_child(__self: mut DocumentFragment, child: mut Node) -> mut Node = "
    const r = #var(__self).removeChild(#fun(Node::as_js)(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun DocumentFragment::add_event_listener(__self: mut DocumentFragment, type: String, callback: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).addEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(callback)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun DocumentFragment::remove_event_listener(__self: mut DocumentFragment, type: String, callback: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).removeEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(callback)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun DocumentFragment::dispatch_event(__self: mut DocumentFragment, event: mut Event) -> Bool = "
    const r = #var(__self).dispatchEvent(#fun(Event::as_js)(#var(event)));
    return #fun(Bool::from_js)(r);
"

pub ext fun DocumentFragment::get_element_by_id(__self: mut DocumentFragment, element_id: String) -> Option[mut Element] = "
    const r = #var(__self).getElementById(#fun(String::as_js)(#var(element_id)));
    return #fun(Option::from_js[mut Element])(r);
"

pub ext fun DocumentFragment::prepend(__self: mut DocumentFragment, ...nodes: List[JsValue]) -> Unit = "
    const r = #var(__self).prepend((#var(nodes)).map(v => v));
    return #fun(Unit::from_js)(r);
"

pub ext fun DocumentFragment::append(__self: mut DocumentFragment, ...nodes: List[JsValue]) -> Unit = "
    const r = #var(__self).append((#var(nodes)).map(v => v));
    return #fun(Unit::from_js)(r);
"

pub ext fun DocumentFragment::replace_children(__self: mut DocumentFragment, ...nodes: List[JsValue]) -> Unit = "
    const r = #var(__self).replaceChildren((#var(nodes)).map(v => v));
    return #fun(Unit::from_js)(r);
"

pub ext fun DocumentFragment::move_before(__self: mut DocumentFragment, node: mut Node, child: Option[mut Node]) -> Unit = "
    const r = #var(__self).moveBefore(#fun(Node::as_js)(#var(node)), #fun(Option::as_js[mut Node])(#var(child)));
    return #fun(Unit::from_js)(r);
"

pub ext fun DocumentFragment::query_selector(__self: mut DocumentFragment, selectors: String) -> Option[mut Element] = "
    const r = #var(__self).querySelector(#fun(String::as_js)(#var(selectors)));
    return #fun(Option::from_js[mut Element])(r);
"

pub ext fun DocumentFragment::query_selector_all(__self: mut DocumentFragment, selectors: String) -> mut NodeList = "
    const r = #var(__self).querySelectorAll(#fun(String::as_js)(#var(selectors)));
    return #fun(NodeList::from_js)(r);
"

pub fun DocumentFragment::as_js(self: DocumentFragment) -> JsValue = JsValue::unsafe_from[DocumentFragment](self)

pub fun DocumentFragment::from_js(v: JsValue) -> mut DocumentFragment = JsValue::unsafe_as[mut DocumentFragment](v)

pub val DocumentFragment::ELEMENT_NODE: Int = 1
pub val DocumentFragment::ATTRIBUTE_NODE: Int = 2
pub val DocumentFragment::TEXT_NODE: Int = 3
pub val DocumentFragment::CDATA_SECTION_NODE: Int = 4
pub val DocumentFragment::ENTITY_REFERENCE_NODE: Int = 5
pub val DocumentFragment::ENTITY_NODE: Int = 6
pub val DocumentFragment::PROCESSING_INSTRUCTION_NODE: Int = 7
pub val DocumentFragment::COMMENT_NODE: Int = 8
pub val DocumentFragment::DOCUMENT_NODE: Int = 9
pub val DocumentFragment::DOCUMENT_TYPE_NODE: Int = 10
pub val DocumentFragment::DOCUMENT_FRAGMENT_NODE: Int = 11
pub val DocumentFragment::NOTATION_NODE: Int = 12
pub val DocumentFragment::DOCUMENT_POSITION_DISCONNECTED: Int = 1
pub val DocumentFragment::DOCUMENT_POSITION_PRECEDING: Int = 2
pub val DocumentFragment::DOCUMENT_POSITION_FOLLOWING: Int = 4
pub val DocumentFragment::DOCUMENT_POSITION_CONTAINS: Int = 8
pub val DocumentFragment::DOCUMENT_POSITION_CONTAINED_BY: Int = 16
pub val DocumentFragment::DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Int = 32

struct ShadowRoot()

/// Converts a reference to 'ShadowRoot' to a reference to 'DocumentFragment'.
/// This does not involve manipulating the object or reference.
pub ext fun ShadowRoot::as_document_fragment(self: ShadowRoot) -> DocumentFragment = "return #var(self);"

/// Converts a mutable reference to 'ShadowRoot' to a mutable reference to 'DocumentFragment'.
/// This does not involve manipulating the object or reference.
pub ext fun ShadowRoot::as_mdocument_fragment(self: mut ShadowRoot) -> mut DocumentFragment = "return #var(self);"

/// Attempts to convert a reference to 'DocumentFragment' to a reference to 'ShadowRoot'.
/// The conversion may fail and panic if 'base' is not a reference to 'ShadowRoot' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun ShadowRoot::from_document_fragment(base: DocumentFragment) -> ShadowRoot = "
    if(#var(base) instanceof ShadowRoot) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'DocumentFragment' to 'ShadowRoot'!\");
"

/// Attempts to convert a mutable reference to 'DocumentFragment' to a mutable reference to 'ShadowRoot'.
/// The conversion may fail and panic if 'base' is not a reference to 'ShadowRoot' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun ShadowRoot::from_mdocument_fragment(base: mut DocumentFragment) -> mut ShadowRoot = "
    if(#var(base) instanceof ShadowRoot) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'DocumentFragment' to 'ShadowRoot'!\");
"

/// Converts a reference to 'ShadowRoot' to a reference to 'Node'.
/// This does not involve manipulating the object or reference.
pub ext fun ShadowRoot::as_node(self: ShadowRoot) -> Node = "return #var(self);"

/// Converts a mutable reference to 'ShadowRoot' to a mutable reference to 'Node'.
/// This does not involve manipulating the object or reference.
pub ext fun ShadowRoot::as_mnode(self: mut ShadowRoot) -> mut Node = "return #var(self);"

/// Attempts to convert a reference to 'Node' to a reference to 'ShadowRoot'.
/// The conversion may fail and panic if 'base' is not a reference to 'ShadowRoot' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun ShadowRoot::from_node(base: Node) -> ShadowRoot = "
    if(#var(base) instanceof ShadowRoot) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Node' to 'ShadowRoot'!\");
"

/// Attempts to convert a mutable reference to 'Node' to a mutable reference to 'ShadowRoot'.
/// The conversion may fail and panic if 'base' is not a reference to 'ShadowRoot' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun ShadowRoot::from_mnode(base: mut Node) -> mut ShadowRoot = "
    if(#var(base) instanceof ShadowRoot) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Node' to 'ShadowRoot'!\");
"

/// Converts a reference to 'ShadowRoot' to a reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun ShadowRoot::as_event_target(self: ShadowRoot) -> EventTarget = "return #var(self);"

/// Converts a mutable reference to 'ShadowRoot' to a mutable reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun ShadowRoot::as_mevent_target(self: mut ShadowRoot) -> mut EventTarget = "return #var(self);"

/// Attempts to convert a reference to 'EventTarget' to a reference to 'ShadowRoot'.
/// The conversion may fail and panic if 'base' is not a reference to 'ShadowRoot' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun ShadowRoot::from_event_target(base: EventTarget) -> ShadowRoot = "
    if(#var(base) instanceof ShadowRoot) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'ShadowRoot'!\");
"

/// Attempts to convert a mutable reference to 'EventTarget' to a mutable reference to 'ShadowRoot'.
/// The conversion may fail and panic if 'base' is not a reference to 'ShadowRoot' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun ShadowRoot::from_mevent_target(base: mut EventTarget) -> mut ShadowRoot = "
    if(#var(base) instanceof ShadowRoot) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'ShadowRoot'!\");
"

pub ext fun ShadowRoot::mode(self: ShadowRoot) -> String
    = "return #fun(String::from_js)(#var(self).mode);"

pub ext fun ShadowRoot::delegates_focus(self: ShadowRoot) -> Bool
    = "return #fun(Bool::from_js)(#var(self).delegatesFocus);"

pub ext fun ShadowRoot::slot_assignment(self: ShadowRoot) -> String
    = "return #fun(String::from_js)(#var(self).slotAssignment);"

pub ext fun ShadowRoot::clonable(self: ShadowRoot) -> Bool
    = "return #fun(Bool::from_js)(#var(self).clonable);"

pub ext fun ShadowRoot::serializable(self: ShadowRoot) -> Bool
    = "return #fun(Bool::from_js)(#var(self).serializable);"

pub ext fun ShadowRoot::host(self: ShadowRoot) -> mut Element
    = "return #fun(Element::from_js)(#var(self).host);"

pub ext fun ShadowRoot::onslotchange(self: ShadowRoot) -> JsValue
    = "return #var(self).onslotchange;"

pub ext fun ShadowRoot::set_onslotchange(self: mut ShadowRoot, value: JsValue)
    = "#var(self).onslotchange = #var(value);"

pub ext fun ShadowRoot::node_type(self: ShadowRoot) -> Int
    = "return #fun(Int::from_js)(#var(self).nodeType);"

pub ext fun ShadowRoot::node_name(self: ShadowRoot) -> String
    = "return #fun(String::from_js)(#var(self).nodeName);"

pub ext fun ShadowRoot::base_uri(self: ShadowRoot) -> String
    = "return #fun(String::from_js)(#var(self).baseURI);"

pub ext fun ShadowRoot::is_connected(self: ShadowRoot) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isConnected);"

pub ext fun ShadowRoot::owner_document(self: ShadowRoot) -> Option[mut Document]
    = "return #fun(Option::from_js[mut Document])(#var(self).ownerDocument);"

pub ext fun ShadowRoot::parent_node(self: ShadowRoot) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).parentNode);"

pub ext fun ShadowRoot::parent_element(self: ShadowRoot) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).parentElement);"

pub ext fun ShadowRoot::child_nodes(self: ShadowRoot) -> mut NodeList
    = "return #fun(NodeList::from_js)(#var(self).childNodes);"

pub ext fun ShadowRoot::first_child(self: ShadowRoot) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).firstChild);"

pub ext fun ShadowRoot::last_child(self: ShadowRoot) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).lastChild);"

pub ext fun ShadowRoot::previous_sibling(self: ShadowRoot) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).previousSibling);"

pub ext fun ShadowRoot::next_sibling(self: ShadowRoot) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).nextSibling);"

pub ext fun ShadowRoot::node_value(self: ShadowRoot) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).nodeValue);"

pub ext fun ShadowRoot::set_node_value(self: mut ShadowRoot, value: Option[String])
    = "#var(self).nodeValue = #fun(Option::as_js[String])(#var(value));"

pub ext fun ShadowRoot::text_content(self: ShadowRoot) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).textContent);"

pub ext fun ShadowRoot::set_text_content(self: mut ShadowRoot, value: Option[String])
    = "#var(self).textContent = #fun(Option::as_js[String])(#var(value));"

pub ext fun ShadowRoot::custom_element_registry(self: ShadowRoot) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).customElementRegistry);"

pub ext fun ShadowRoot::get_root_node(__self: mut ShadowRoot, options: mut GetRootNodeOptions) -> mut Node = "
    const r = #var(__self).getRootNode(#fun(GetRootNodeOptions::as_js)(#var(options)));
    return #fun(Node::from_js)(r);
"

pub ext fun ShadowRoot::has_child_nodes(__self: mut ShadowRoot) -> Bool = "
    const r = #var(__self).hasChildNodes();
    return #fun(Bool::from_js)(r);
"

pub ext fun ShadowRoot::normalize(__self: mut ShadowRoot) -> Unit = "
    const r = #var(__self).normalize();
    return #fun(Unit::from_js)(r);
"

pub ext fun ShadowRoot::clone_node(__self: mut ShadowRoot, subtree: Bool) -> mut Node = "
    const r = #var(__self).cloneNode(#fun(Bool::as_js)(#var(subtree)));
    return #fun(Node::from_js)(r);
"

pub ext fun ShadowRoot::is_equal_node(__self: mut ShadowRoot, other_node: Option[mut Node]) -> Bool = "
    const r = #var(__self).isEqualNode(#fun(Option::as_js[mut Node])(#var(other_node)));
    return #fun(Bool::from_js)(r);
"

pub ext fun ShadowRoot::is_same_node(__self: mut ShadowRoot, other_node: Option[mut Node]) -> Bool = "
    const r = #var(__self).isSameNode(#fun(Option::as_js[mut Node])(#var(other_node)));
    return #fun(Bool::from_js)(r);
"

pub ext fun ShadowRoot::compare_document_position(__self: mut ShadowRoot, other: mut Node) -> Int = "
    const r = #var(__self).compareDocumentPosition(#fun(Node::as_js)(#var(other)));
    return #fun(Int::from_js)(r);
"

pub ext fun ShadowRoot::contains(__self: mut ShadowRoot, other: Option[mut Node]) -> Bool = "
    const r = #var(__self).contains(#fun(Option::as_js[mut Node])(#var(other)));
    return #fun(Bool::from_js)(r);
"

pub ext fun ShadowRoot::lookup_prefix(__self: mut ShadowRoot, namespace: Option[String]) -> Option[String] = "
    const r = #var(__self).lookupPrefix(#fun(Option::as_js[String])(#var(namespace)));
    return #fun(Option::from_js[String])(r);
"

pub ext fun ShadowRoot::lookup_namespace_uri(__self: mut ShadowRoot, prefix: Option[String]) -> Option[String] = "
    const r = #var(__self).lookupNamespaceURI(#fun(Option::as_js[String])(#var(prefix)));
    return #fun(Option::from_js[String])(r);
"

pub ext fun ShadowRoot::is_default_namespace(__self: mut ShadowRoot, namespace: Option[String]) -> Bool = "
    const r = #var(__self).isDefaultNamespace(#fun(Option::as_js[String])(#var(namespace)));
    return #fun(Bool::from_js)(r);
"

pub ext fun ShadowRoot::insert_before(__self: mut ShadowRoot, node: mut Node, child: Option[mut Node]) -> mut Node = "
    const r = #var(__self).insertBefore(#fun(Node::as_js)(#var(node)), #fun(Option::as_js[mut Node])(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun ShadowRoot::append_child(__self: mut ShadowRoot, node: mut Node) -> mut Node = "
    const r = #var(__self).appendChild(#fun(Node::as_js)(#var(node)));
    return #fun(Node::from_js)(r);
"

pub ext fun ShadowRoot::replace_child(__self: mut ShadowRoot, node: mut Node, child: mut Node) -> mut Node = "
    const r = #var(__self).replaceChild(#fun(Node::as_js)(#var(node)), #fun(Node::as_js)(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun ShadowRoot::remove_child(__self: mut ShadowRoot, child: mut Node) -> mut Node = "
    const r = #var(__self).removeChild(#fun(Node::as_js)(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun ShadowRoot::add_event_listener(__self: mut ShadowRoot, type: String, callback: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).addEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(callback)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun ShadowRoot::remove_event_listener(__self: mut ShadowRoot, type: String, callback: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).removeEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(callback)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun ShadowRoot::dispatch_event(__self: mut ShadowRoot, event: mut Event) -> Bool = "
    const r = #var(__self).dispatchEvent(#fun(Event::as_js)(#var(event)));
    return #fun(Bool::from_js)(r);
"

pub fun ShadowRoot::as_js(self: ShadowRoot) -> JsValue = JsValue::unsafe_from[ShadowRoot](self)

pub fun ShadowRoot::from_js(v: JsValue) -> mut ShadowRoot = JsValue::unsafe_as[mut ShadowRoot](v)

pub val ShadowRoot::ELEMENT_NODE: Int = 1
pub val ShadowRoot::ATTRIBUTE_NODE: Int = 2
pub val ShadowRoot::TEXT_NODE: Int = 3
pub val ShadowRoot::CDATA_SECTION_NODE: Int = 4
pub val ShadowRoot::ENTITY_REFERENCE_NODE: Int = 5
pub val ShadowRoot::ENTITY_NODE: Int = 6
pub val ShadowRoot::PROCESSING_INSTRUCTION_NODE: Int = 7
pub val ShadowRoot::COMMENT_NODE: Int = 8
pub val ShadowRoot::DOCUMENT_NODE: Int = 9
pub val ShadowRoot::DOCUMENT_TYPE_NODE: Int = 10
pub val ShadowRoot::DOCUMENT_FRAGMENT_NODE: Int = 11
pub val ShadowRoot::NOTATION_NODE: Int = 12
pub val ShadowRoot::DOCUMENT_POSITION_DISCONNECTED: Int = 1
pub val ShadowRoot::DOCUMENT_POSITION_PRECEDING: Int = 2
pub val ShadowRoot::DOCUMENT_POSITION_FOLLOWING: Int = 4
pub val ShadowRoot::DOCUMENT_POSITION_CONTAINS: Int = 8
pub val ShadowRoot::DOCUMENT_POSITION_CONTAINED_BY: Int = 16
pub val ShadowRoot::DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Int = 32

pub val ShadowRootMode::Open: String = "open"
pub val ShadowRootMode::Closed: String = "closed"

pub val SlotAssignmentMode::Manual: String = "manual"
pub val SlotAssignmentMode::Named: String = "named"

struct Element()

/// Converts a reference to 'Element' to a reference to 'Node'.
/// This does not involve manipulating the object or reference.
pub ext fun Element::as_node(self: Element) -> Node = "return #var(self);"

/// Converts a mutable reference to 'Element' to a mutable reference to 'Node'.
/// This does not involve manipulating the object or reference.
pub ext fun Element::as_mnode(self: mut Element) -> mut Node = "return #var(self);"

/// Attempts to convert a reference to 'Node' to a reference to 'Element'.
/// The conversion may fail and panic if 'base' is not a reference to 'Element' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Element::from_node(base: Node) -> Element = "
    if(#var(base) instanceof Element) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Node' to 'Element'!\");
"

/// Attempts to convert a mutable reference to 'Node' to a mutable reference to 'Element'.
/// The conversion may fail and panic if 'base' is not a reference to 'Element' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Element::from_mnode(base: mut Node) -> mut Element = "
    if(#var(base) instanceof Element) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Node' to 'Element'!\");
"

/// Converts a reference to 'Element' to a reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun Element::as_event_target(self: Element) -> EventTarget = "return #var(self);"

/// Converts a mutable reference to 'Element' to a mutable reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun Element::as_mevent_target(self: mut Element) -> mut EventTarget = "return #var(self);"

/// Attempts to convert a reference to 'EventTarget' to a reference to 'Element'.
/// The conversion may fail and panic if 'base' is not a reference to 'Element' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Element::from_event_target(base: EventTarget) -> Element = "
    if(#var(base) instanceof Element) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'Element'!\");
"

/// Attempts to convert a mutable reference to 'EventTarget' to a mutable reference to 'Element'.
/// The conversion may fail and panic if 'base' is not a reference to 'Element' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Element::from_mevent_target(base: mut EventTarget) -> mut Element = "
    if(#var(base) instanceof Element) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'Element'!\");
"

pub ext fun Element::namespace_uri(self: Element) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).namespaceURI);"

pub ext fun Element::prefix(self: Element) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).prefix);"

pub ext fun Element::local_name(self: Element) -> String
    = "return #fun(String::from_js)(#var(self).localName);"

pub ext fun Element::tag_name(self: Element) -> String
    = "return #fun(String::from_js)(#var(self).tagName);"

pub ext fun Element::id(self: Element) -> String
    = "return #fun(String::from_js)(#var(self).id);"

pub ext fun Element::set_id(self: mut Element, value: String)
    = "#var(self).id = #fun(String::as_js)(#var(value));"

pub ext fun Element::class_name(self: Element) -> String
    = "return #fun(String::from_js)(#var(self).className);"

pub ext fun Element::set_class_name(self: mut Element, value: String)
    = "#var(self).className = #fun(String::as_js)(#var(value));"

pub ext fun Element::class_list(self: Element) -> mut DOMTokenList
    = "return #fun(DOMTokenList::from_js)(#var(self).classList);"

pub ext fun Element::slot(self: Element) -> String
    = "return #fun(String::from_js)(#var(self).slot);"

pub ext fun Element::set_slot(self: mut Element, value: String)
    = "#var(self).slot = #fun(String::as_js)(#var(value));"

pub ext fun Element::attributes(self: Element) -> mut NamedNodeMap
    = "return #fun(NamedNodeMap::from_js)(#var(self).attributes);"

pub ext fun Element::shadow_root(self: Element) -> Option[mut ShadowRoot]
    = "return #fun(Option::from_js[mut ShadowRoot])(#var(self).shadowRoot);"

pub ext fun Element::custom_element_registry(self: Element) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).customElementRegistry);"

pub ext fun Element::node_type(self: Element) -> Int
    = "return #fun(Int::from_js)(#var(self).nodeType);"

pub ext fun Element::node_name(self: Element) -> String
    = "return #fun(String::from_js)(#var(self).nodeName);"

pub ext fun Element::base_uri(self: Element) -> String
    = "return #fun(String::from_js)(#var(self).baseURI);"

pub ext fun Element::is_connected(self: Element) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isConnected);"

pub ext fun Element::owner_document(self: Element) -> Option[mut Document]
    = "return #fun(Option::from_js[mut Document])(#var(self).ownerDocument);"

pub ext fun Element::parent_node(self: Element) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).parentNode);"

pub ext fun Element::parent_element(self: Element) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).parentElement);"

pub ext fun Element::child_nodes(self: Element) -> mut NodeList
    = "return #fun(NodeList::from_js)(#var(self).childNodes);"

pub ext fun Element::first_child(self: Element) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).firstChild);"

pub ext fun Element::last_child(self: Element) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).lastChild);"

pub ext fun Element::previous_sibling(self: Element) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).previousSibling);"

pub ext fun Element::next_sibling(self: Element) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).nextSibling);"

pub ext fun Element::node_value(self: Element) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).nodeValue);"

pub ext fun Element::set_node_value(self: mut Element, value: Option[String])
    = "#var(self).nodeValue = #fun(Option::as_js[String])(#var(value));"

pub ext fun Element::text_content(self: Element) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).textContent);"

pub ext fun Element::set_text_content(self: mut Element, value: Option[String])
    = "#var(self).textContent = #fun(Option::as_js[String])(#var(value));"

pub ext fun Element::children(self: Element) -> mut HTMLCollection
    = "return #fun(HTMLCollection::from_js)(#var(self).children);"

pub ext fun Element::first_element_child(self: Element) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).firstElementChild);"

pub ext fun Element::last_element_child(self: Element) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).lastElementChild);"

pub ext fun Element::child_element_count(self: Element) -> Int
    = "return #fun(Int::from_js)(#var(self).childElementCount);"

pub ext fun Element::previous_element_sibling(self: Element) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).previousElementSibling);"

pub ext fun Element::next_element_sibling(self: Element) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).nextElementSibling);"

pub ext fun Element::assigned_slot(self: Element) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).assignedSlot);"

pub ext fun Element::has_attributes(__self: mut Element) -> Bool = "
    const r = #var(__self).hasAttributes();
    return #fun(Bool::from_js)(r);
"

pub ext fun Element::get_attribute_names(__self: mut Element) -> List[String] = "
    const r = #var(__self).getAttributeNames();
    return #fun(List::from_js[String])(r);
"

pub ext fun Element::get_attribute(__self: mut Element, qualified_name: String) -> Option[String] = "
    const r = #var(__self).getAttribute(#fun(String::as_js)(#var(qualified_name)));
    return #fun(Option::from_js[String])(r);
"

pub ext fun Element::get_attribute_ns(__self: mut Element, namespace: Option[String], local_name: String) -> Option[String] = "
    const r = #var(__self).getAttributeNS(#fun(Option::as_js[String])(#var(namespace)), #fun(String::as_js)(#var(local_name)));
    return #fun(Option::from_js[String])(r);
"

pub ext fun Element::set_attribute(__self: mut Element, qualified_name: String, value: String) -> Unit = "
    const r = #var(__self).setAttribute(#fun(String::as_js)(#var(qualified_name)), #fun(String::as_js)(#var(value)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Element::set_attribute_ns(__self: mut Element, namespace: Option[String], qualified_name: String, value: String) -> Unit = "
    const r = #var(__self).setAttributeNS(#fun(Option::as_js[String])(#var(namespace)), #fun(String::as_js)(#var(qualified_name)), #fun(String::as_js)(#var(value)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Element::remove_attribute(__self: mut Element, qualified_name: String) -> Unit = "
    const r = #var(__self).removeAttribute(#fun(String::as_js)(#var(qualified_name)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Element::remove_attribute_ns(__self: mut Element, namespace: Option[String], local_name: String) -> Unit = "
    const r = #var(__self).removeAttributeNS(#fun(Option::as_js[String])(#var(namespace)), #fun(String::as_js)(#var(local_name)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Element::toggle_attribute(__self: mut Element, qualified_name: String, force: Bool) -> Bool = "
    const r = #var(__self).toggleAttribute(#fun(String::as_js)(#var(qualified_name)), #fun(Bool::as_js)(#var(force)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Element::has_attribute(__self: mut Element, qualified_name: String) -> Bool = "
    const r = #var(__self).hasAttribute(#fun(String::as_js)(#var(qualified_name)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Element::has_attribute_ns(__self: mut Element, namespace: Option[String], local_name: String) -> Bool = "
    const r = #var(__self).hasAttributeNS(#fun(Option::as_js[String])(#var(namespace)), #fun(String::as_js)(#var(local_name)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Element::get_attribute_node(__self: mut Element, qualified_name: String) -> Option[mut Attr] = "
    const r = #var(__self).getAttributeNode(#fun(String::as_js)(#var(qualified_name)));
    return #fun(Option::from_js[mut Attr])(r);
"

pub ext fun Element::get_attribute_node_ns(__self: mut Element, namespace: Option[String], local_name: String) -> Option[mut Attr] = "
    const r = #var(__self).getAttributeNodeNS(#fun(Option::as_js[String])(#var(namespace)), #fun(String::as_js)(#var(local_name)));
    return #fun(Option::from_js[mut Attr])(r);
"

pub ext fun Element::set_attribute_node(__self: mut Element, attr: mut Attr) -> Option[mut Attr] = "
    const r = #var(__self).setAttributeNode(#fun(Attr::as_js)(#var(attr)));
    return #fun(Option::from_js[mut Attr])(r);
"

pub ext fun Element::set_attribute_node_ns(__self: mut Element, attr: mut Attr) -> Option[mut Attr] = "
    const r = #var(__self).setAttributeNodeNS(#fun(Attr::as_js)(#var(attr)));
    return #fun(Option::from_js[mut Attr])(r);
"

pub ext fun Element::remove_attribute_node(__self: mut Element, attr: mut Attr) -> mut Attr = "
    const r = #var(__self).removeAttributeNode(#fun(Attr::as_js)(#var(attr)));
    return #fun(Attr::from_js)(r);
"

pub ext fun Element::attach_shadow(__self: mut Element, init: mut ShadowRootInit) -> mut ShadowRoot = "
    const r = #var(__self).attachShadow(#fun(ShadowRootInit::as_js)(#var(init)));
    return #fun(ShadowRoot::from_js)(r);
"

pub ext fun Element::closest(__self: mut Element, selectors: String) -> Option[mut Element] = "
    const r = #var(__self).closest(#fun(String::as_js)(#var(selectors)));
    return #fun(Option::from_js[mut Element])(r);
"

pub ext fun Element::matches(__self: mut Element, selectors: String) -> Bool = "
    const r = #var(__self).matches(#fun(String::as_js)(#var(selectors)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Element::webkit_matches_selector(__self: mut Element, selectors: String) -> Bool = "
    const r = #var(__self).webkitMatchesSelector(#fun(String::as_js)(#var(selectors)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Element::get_elements_by_tag_name(__self: mut Element, qualified_name: String) -> mut HTMLCollection = "
    const r = #var(__self).getElementsByTagName(#fun(String::as_js)(#var(qualified_name)));
    return #fun(HTMLCollection::from_js)(r);
"

pub ext fun Element::get_elements_by_tag_name_ns(__self: mut Element, namespace: Option[String], local_name: String) -> mut HTMLCollection = "
    const r = #var(__self).getElementsByTagNameNS(#fun(Option::as_js[String])(#var(namespace)), #fun(String::as_js)(#var(local_name)));
    return #fun(HTMLCollection::from_js)(r);
"

pub ext fun Element::get_elements_by_class_name(__self: mut Element, class_names: String) -> mut HTMLCollection = "
    const r = #var(__self).getElementsByClassName(#fun(String::as_js)(#var(class_names)));
    return #fun(HTMLCollection::from_js)(r);
"

pub ext fun Element::insert_adjacent_element(__self: mut Element, where: String, element: mut Element) -> Option[mut Element] = "
    const r = #var(__self).insertAdjacentElement(#fun(String::as_js)(#var(where)), #fun(Element::as_js)(#var(element)));
    return #fun(Option::from_js[mut Element])(r);
"

pub ext fun Element::insert_adjacent_text(__self: mut Element, where: String, data: String) -> Unit = "
    const r = #var(__self).insertAdjacentText(#fun(String::as_js)(#var(where)), #fun(String::as_js)(#var(data)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Element::get_root_node(__self: mut Element, options: mut GetRootNodeOptions) -> mut Node = "
    const r = #var(__self).getRootNode(#fun(GetRootNodeOptions::as_js)(#var(options)));
    return #fun(Node::from_js)(r);
"

pub ext fun Element::has_child_nodes(__self: mut Element) -> Bool = "
    const r = #var(__self).hasChildNodes();
    return #fun(Bool::from_js)(r);
"

pub ext fun Element::normalize(__self: mut Element) -> Unit = "
    const r = #var(__self).normalize();
    return #fun(Unit::from_js)(r);
"

pub ext fun Element::clone_node(__self: mut Element, subtree: Bool) -> mut Node = "
    const r = #var(__self).cloneNode(#fun(Bool::as_js)(#var(subtree)));
    return #fun(Node::from_js)(r);
"

pub ext fun Element::is_equal_node(__self: mut Element, other_node: Option[mut Node]) -> Bool = "
    const r = #var(__self).isEqualNode(#fun(Option::as_js[mut Node])(#var(other_node)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Element::is_same_node(__self: mut Element, other_node: Option[mut Node]) -> Bool = "
    const r = #var(__self).isSameNode(#fun(Option::as_js[mut Node])(#var(other_node)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Element::compare_document_position(__self: mut Element, other: mut Node) -> Int = "
    const r = #var(__self).compareDocumentPosition(#fun(Node::as_js)(#var(other)));
    return #fun(Int::from_js)(r);
"

pub ext fun Element::contains(__self: mut Element, other: Option[mut Node]) -> Bool = "
    const r = #var(__self).contains(#fun(Option::as_js[mut Node])(#var(other)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Element::lookup_prefix(__self: mut Element, namespace: Option[String]) -> Option[String] = "
    const r = #var(__self).lookupPrefix(#fun(Option::as_js[String])(#var(namespace)));
    return #fun(Option::from_js[String])(r);
"

pub ext fun Element::lookup_namespace_uri(__self: mut Element, prefix: Option[String]) -> Option[String] = "
    const r = #var(__self).lookupNamespaceURI(#fun(Option::as_js[String])(#var(prefix)));
    return #fun(Option::from_js[String])(r);
"

pub ext fun Element::is_default_namespace(__self: mut Element, namespace: Option[String]) -> Bool = "
    const r = #var(__self).isDefaultNamespace(#fun(Option::as_js[String])(#var(namespace)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Element::insert_before(__self: mut Element, node: mut Node, child: Option[mut Node]) -> mut Node = "
    const r = #var(__self).insertBefore(#fun(Node::as_js)(#var(node)), #fun(Option::as_js[mut Node])(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun Element::append_child(__self: mut Element, node: mut Node) -> mut Node = "
    const r = #var(__self).appendChild(#fun(Node::as_js)(#var(node)));
    return #fun(Node::from_js)(r);
"

pub ext fun Element::replace_child(__self: mut Element, node: mut Node, child: mut Node) -> mut Node = "
    const r = #var(__self).replaceChild(#fun(Node::as_js)(#var(node)), #fun(Node::as_js)(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun Element::remove_child(__self: mut Element, child: mut Node) -> mut Node = "
    const r = #var(__self).removeChild(#fun(Node::as_js)(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun Element::add_event_listener(__self: mut Element, type: String, callback: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).addEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(callback)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun Element::remove_event_listener(__self: mut Element, type: String, callback: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).removeEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(callback)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun Element::dispatch_event(__self: mut Element, event: mut Event) -> Bool = "
    const r = #var(__self).dispatchEvent(#fun(Event::as_js)(#var(event)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Element::prepend(__self: mut Element, ...nodes: List[JsValue]) -> Unit = "
    const r = #var(__self).prepend((#var(nodes)).map(v => v));
    return #fun(Unit::from_js)(r);
"

pub ext fun Element::append(__self: mut Element, ...nodes: List[JsValue]) -> Unit = "
    const r = #var(__self).append((#var(nodes)).map(v => v));
    return #fun(Unit::from_js)(r);
"

pub ext fun Element::replace_children(__self: mut Element, ...nodes: List[JsValue]) -> Unit = "
    const r = #var(__self).replaceChildren((#var(nodes)).map(v => v));
    return #fun(Unit::from_js)(r);
"

pub ext fun Element::move_before(__self: mut Element, node: mut Node, child: Option[mut Node]) -> Unit = "
    const r = #var(__self).moveBefore(#fun(Node::as_js)(#var(node)), #fun(Option::as_js[mut Node])(#var(child)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Element::query_selector(__self: mut Element, selectors: String) -> Option[mut Element] = "
    const r = #var(__self).querySelector(#fun(String::as_js)(#var(selectors)));
    return #fun(Option::from_js[mut Element])(r);
"

pub ext fun Element::query_selector_all(__self: mut Element, selectors: String) -> mut NodeList = "
    const r = #var(__self).querySelectorAll(#fun(String::as_js)(#var(selectors)));
    return #fun(NodeList::from_js)(r);
"

pub ext fun Element::before(__self: mut Element, ...nodes: List[JsValue]) -> Unit = "
    const r = #var(__self).before((#var(nodes)).map(v => v));
    return #fun(Unit::from_js)(r);
"

pub ext fun Element::after(__self: mut Element, ...nodes: List[JsValue]) -> Unit = "
    const r = #var(__self).after((#var(nodes)).map(v => v));
    return #fun(Unit::from_js)(r);
"

pub ext fun Element::replace_with(__self: mut Element, ...nodes: List[JsValue]) -> Unit = "
    const r = #var(__self).replaceWith((#var(nodes)).map(v => v));
    return #fun(Unit::from_js)(r);
"

pub ext fun Element::remove(__self: mut Element) -> Unit = "
    const r = #var(__self).remove();
    return #fun(Unit::from_js)(r);
"

pub fun Element::as_js(self: Element) -> JsValue = JsValue::unsafe_from[Element](self)

pub fun Element::from_js(v: JsValue) -> mut Element = JsValue::unsafe_as[mut Element](v)

pub val Element::ELEMENT_NODE: Int = 1
pub val Element::ATTRIBUTE_NODE: Int = 2
pub val Element::TEXT_NODE: Int = 3
pub val Element::CDATA_SECTION_NODE: Int = 4
pub val Element::ENTITY_REFERENCE_NODE: Int = 5
pub val Element::ENTITY_NODE: Int = 6
pub val Element::PROCESSING_INSTRUCTION_NODE: Int = 7
pub val Element::COMMENT_NODE: Int = 8
pub val Element::DOCUMENT_NODE: Int = 9
pub val Element::DOCUMENT_TYPE_NODE: Int = 10
pub val Element::DOCUMENT_FRAGMENT_NODE: Int = 11
pub val Element::NOTATION_NODE: Int = 12
pub val Element::DOCUMENT_POSITION_DISCONNECTED: Int = 1
pub val Element::DOCUMENT_POSITION_PRECEDING: Int = 2
pub val Element::DOCUMENT_POSITION_FOLLOWING: Int = 4
pub val Element::DOCUMENT_POSITION_CONTAINS: Int = 8
pub val Element::DOCUMENT_POSITION_CONTAINED_BY: Int = 16
pub val Element::DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Int = 32

pub struct ShadowRootInit(
    mode: String,
    delegates_focus: Option[Bool],
    slot_assignment: Option[String],
    clonable: Option[Bool],
    serializable: Option[Bool],
    custom_element_registry: Option[JsValue]
)

pub fun ShadowRootInit::default(mode: String) -> mut ShadowRootInit
    = ShadowRootInit(mode, Option::Some(false), Option::Some("named"), Option::Some(false), Option::Some(false), Option::None)

pub ext fun ShadowRootInit::from_js(value: JsValue) -> mut ShadowRootInit = "
    const r = {};
    r.mode = #fun(String::from_js)(#var(value).mode);
    r.delegates_focus = #fun(Option::from_js[Bool])(#var(value).delegatesFocus);
    r.slot_assignment = #fun(Option::from_js[String])(#var(value).slotAssignment);
    r.clonable = #fun(Option::from_js[Bool])(#var(value).clonable);
    r.serializable = #fun(Option::from_js[Bool])(#var(value).serializable);
    r.custom_element_registry = #fun(Option::from_js[JsValue])(#var(value).customElementRegistry);
    return r;
"

pub ext fun ShadowRootInit::as_js(self: ShadowRootInit) -> JsValue = "
    const r = {};
    r.mode = #var(self).mode;
    r.delegatesFocus = #fun(Option::as_js[Bool])(#var(self).delegates_focus);
    r.slotAssignment = #fun(Option::as_js[String])(#var(self).slot_assignment);
    r.clonable = #fun(Option::as_js[Bool])(#var(self).clonable);
    r.serializable = #fun(Option::as_js[Bool])(#var(self).serializable);
    r.customElementRegistry = #fun(Option::as_js[JsValue])(#var(self).custom_element_registry);
    return r;
"

struct NamedNodeMap()

pub ext fun NamedNodeMap::length(self: NamedNodeMap) -> Int
    = "return #fun(Int::from_js)(#var(self).length);"

pub ext fun NamedNodeMap::item(__self: mut NamedNodeMap, index: Int) -> Option[mut Attr] = "
    const r = #var(__self).item(#fun(Int::as_js)(#var(index)));
    return #fun(Option::from_js[mut Attr])(r);
"

pub ext fun NamedNodeMap::get_named_item(__self: mut NamedNodeMap, qualified_name: String) -> Option[mut Attr] = "
    const r = #var(__self).getNamedItem(#fun(String::as_js)(#var(qualified_name)));
    return #fun(Option::from_js[mut Attr])(r);
"

pub ext fun NamedNodeMap::get_named_item_ns(__self: mut NamedNodeMap, namespace: Option[String], local_name: String) -> Option[mut Attr] = "
    const r = #var(__self).getNamedItemNS(#fun(Option::as_js[String])(#var(namespace)), #fun(String::as_js)(#var(local_name)));
    return #fun(Option::from_js[mut Attr])(r);
"

pub ext fun NamedNodeMap::set_named_item(__self: mut NamedNodeMap, attr: mut Attr) -> Option[mut Attr] = "
    const r = #var(__self).setNamedItem(#fun(Attr::as_js)(#var(attr)));
    return #fun(Option::from_js[mut Attr])(r);
"

pub ext fun NamedNodeMap::set_named_item_ns(__self: mut NamedNodeMap, attr: mut Attr) -> Option[mut Attr] = "
    const r = #var(__self).setNamedItemNS(#fun(Attr::as_js)(#var(attr)));
    return #fun(Option::from_js[mut Attr])(r);
"

pub ext fun NamedNodeMap::remove_named_item(__self: mut NamedNodeMap, qualified_name: String) -> mut Attr = "
    const r = #var(__self).removeNamedItem(#fun(String::as_js)(#var(qualified_name)));
    return #fun(Attr::from_js)(r);
"

pub ext fun NamedNodeMap::remove_named_item_ns(__self: mut NamedNodeMap, namespace: Option[String], local_name: String) -> mut Attr = "
    const r = #var(__self).removeNamedItemNS(#fun(Option::as_js[String])(#var(namespace)), #fun(String::as_js)(#var(local_name)));
    return #fun(Attr::from_js)(r);
"

pub fun NamedNodeMap::as_js(self: NamedNodeMap) -> JsValue = JsValue::unsafe_from[NamedNodeMap](self)

pub fun NamedNodeMap::from_js(v: JsValue) -> mut NamedNodeMap = JsValue::unsafe_as[mut NamedNodeMap](v)

struct Attr()

/// Converts a reference to 'Attr' to a reference to 'Node'.
/// This does not involve manipulating the object or reference.
pub ext fun Attr::as_node(self: Attr) -> Node = "return #var(self);"

/// Converts a mutable reference to 'Attr' to a mutable reference to 'Node'.
/// This does not involve manipulating the object or reference.
pub ext fun Attr::as_mnode(self: mut Attr) -> mut Node = "return #var(self);"

/// Attempts to convert a reference to 'Node' to a reference to 'Attr'.
/// The conversion may fail and panic if 'base' is not a reference to 'Attr' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Attr::from_node(base: Node) -> Attr = "
    if(#var(base) instanceof Attr) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Node' to 'Attr'!\");
"

/// Attempts to convert a mutable reference to 'Node' to a mutable reference to 'Attr'.
/// The conversion may fail and panic if 'base' is not a reference to 'Attr' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Attr::from_mnode(base: mut Node) -> mut Attr = "
    if(#var(base) instanceof Attr) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Node' to 'Attr'!\");
"

/// Converts a reference to 'Attr' to a reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun Attr::as_event_target(self: Attr) -> EventTarget = "return #var(self);"

/// Converts a mutable reference to 'Attr' to a mutable reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun Attr::as_mevent_target(self: mut Attr) -> mut EventTarget = "return #var(self);"

/// Attempts to convert a reference to 'EventTarget' to a reference to 'Attr'.
/// The conversion may fail and panic if 'base' is not a reference to 'Attr' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Attr::from_event_target(base: EventTarget) -> Attr = "
    if(#var(base) instanceof Attr) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'Attr'!\");
"

/// Attempts to convert a mutable reference to 'EventTarget' to a mutable reference to 'Attr'.
/// The conversion may fail and panic if 'base' is not a reference to 'Attr' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Attr::from_mevent_target(base: mut EventTarget) -> mut Attr = "
    if(#var(base) instanceof Attr) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'Attr'!\");
"

pub ext fun Attr::namespace_uri(self: Attr) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).namespaceURI);"

pub ext fun Attr::prefix(self: Attr) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).prefix);"

pub ext fun Attr::local_name(self: Attr) -> String
    = "return #fun(String::from_js)(#var(self).localName);"

pub ext fun Attr::name(self: Attr) -> String
    = "return #fun(String::from_js)(#var(self).name);"

pub ext fun Attr::value(self: Attr) -> String
    = "return #fun(String::from_js)(#var(self).value);"

pub ext fun Attr::set_value(self: mut Attr, value: String)
    = "#var(self).value = #fun(String::as_js)(#var(value));"

pub ext fun Attr::owner_element(self: Attr) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).ownerElement);"

pub ext fun Attr::specified(self: Attr) -> Bool
    = "return #fun(Bool::from_js)(#var(self).specified);"

pub ext fun Attr::node_type(self: Attr) -> Int
    = "return #fun(Int::from_js)(#var(self).nodeType);"

pub ext fun Attr::node_name(self: Attr) -> String
    = "return #fun(String::from_js)(#var(self).nodeName);"

pub ext fun Attr::base_uri(self: Attr) -> String
    = "return #fun(String::from_js)(#var(self).baseURI);"

pub ext fun Attr::is_connected(self: Attr) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isConnected);"

pub ext fun Attr::owner_document(self: Attr) -> Option[mut Document]
    = "return #fun(Option::from_js[mut Document])(#var(self).ownerDocument);"

pub ext fun Attr::parent_node(self: Attr) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).parentNode);"

pub ext fun Attr::parent_element(self: Attr) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).parentElement);"

pub ext fun Attr::child_nodes(self: Attr) -> mut NodeList
    = "return #fun(NodeList::from_js)(#var(self).childNodes);"

pub ext fun Attr::first_child(self: Attr) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).firstChild);"

pub ext fun Attr::last_child(self: Attr) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).lastChild);"

pub ext fun Attr::previous_sibling(self: Attr) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).previousSibling);"

pub ext fun Attr::next_sibling(self: Attr) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).nextSibling);"

pub ext fun Attr::node_value(self: Attr) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).nodeValue);"

pub ext fun Attr::set_node_value(self: mut Attr, value: Option[String])
    = "#var(self).nodeValue = #fun(Option::as_js[String])(#var(value));"

pub ext fun Attr::text_content(self: Attr) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).textContent);"

pub ext fun Attr::set_text_content(self: mut Attr, value: Option[String])
    = "#var(self).textContent = #fun(Option::as_js[String])(#var(value));"

pub ext fun Attr::get_root_node(__self: mut Attr, options: mut GetRootNodeOptions) -> mut Node = "
    const r = #var(__self).getRootNode(#fun(GetRootNodeOptions::as_js)(#var(options)));
    return #fun(Node::from_js)(r);
"

pub ext fun Attr::has_child_nodes(__self: mut Attr) -> Bool = "
    const r = #var(__self).hasChildNodes();
    return #fun(Bool::from_js)(r);
"

pub ext fun Attr::normalize(__self: mut Attr) -> Unit = "
    const r = #var(__self).normalize();
    return #fun(Unit::from_js)(r);
"

pub ext fun Attr::clone_node(__self: mut Attr, subtree: Bool) -> mut Node = "
    const r = #var(__self).cloneNode(#fun(Bool::as_js)(#var(subtree)));
    return #fun(Node::from_js)(r);
"

pub ext fun Attr::is_equal_node(__self: mut Attr, other_node: Option[mut Node]) -> Bool = "
    const r = #var(__self).isEqualNode(#fun(Option::as_js[mut Node])(#var(other_node)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Attr::is_same_node(__self: mut Attr, other_node: Option[mut Node]) -> Bool = "
    const r = #var(__self).isSameNode(#fun(Option::as_js[mut Node])(#var(other_node)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Attr::compare_document_position(__self: mut Attr, other: mut Node) -> Int = "
    const r = #var(__self).compareDocumentPosition(#fun(Node::as_js)(#var(other)));
    return #fun(Int::from_js)(r);
"

pub ext fun Attr::contains(__self: mut Attr, other: Option[mut Node]) -> Bool = "
    const r = #var(__self).contains(#fun(Option::as_js[mut Node])(#var(other)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Attr::lookup_prefix(__self: mut Attr, namespace: Option[String]) -> Option[String] = "
    const r = #var(__self).lookupPrefix(#fun(Option::as_js[String])(#var(namespace)));
    return #fun(Option::from_js[String])(r);
"

pub ext fun Attr::lookup_namespace_uri(__self: mut Attr, prefix: Option[String]) -> Option[String] = "
    const r = #var(__self).lookupNamespaceURI(#fun(Option::as_js[String])(#var(prefix)));
    return #fun(Option::from_js[String])(r);
"

pub ext fun Attr::is_default_namespace(__self: mut Attr, namespace: Option[String]) -> Bool = "
    const r = #var(__self).isDefaultNamespace(#fun(Option::as_js[String])(#var(namespace)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Attr::insert_before(__self: mut Attr, node: mut Node, child: Option[mut Node]) -> mut Node = "
    const r = #var(__self).insertBefore(#fun(Node::as_js)(#var(node)), #fun(Option::as_js[mut Node])(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun Attr::append_child(__self: mut Attr, node: mut Node) -> mut Node = "
    const r = #var(__self).appendChild(#fun(Node::as_js)(#var(node)));
    return #fun(Node::from_js)(r);
"

pub ext fun Attr::replace_child(__self: mut Attr, node: mut Node, child: mut Node) -> mut Node = "
    const r = #var(__self).replaceChild(#fun(Node::as_js)(#var(node)), #fun(Node::as_js)(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun Attr::remove_child(__self: mut Attr, child: mut Node) -> mut Node = "
    const r = #var(__self).removeChild(#fun(Node::as_js)(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun Attr::add_event_listener(__self: mut Attr, type: String, callback: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).addEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(callback)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun Attr::remove_event_listener(__self: mut Attr, type: String, callback: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).removeEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(callback)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun Attr::dispatch_event(__self: mut Attr, event: mut Event) -> Bool = "
    const r = #var(__self).dispatchEvent(#fun(Event::as_js)(#var(event)));
    return #fun(Bool::from_js)(r);
"

pub fun Attr::as_js(self: Attr) -> JsValue = JsValue::unsafe_from[Attr](self)

pub fun Attr::from_js(v: JsValue) -> mut Attr = JsValue::unsafe_as[mut Attr](v)

pub val Attr::ELEMENT_NODE: Int = 1
pub val Attr::ATTRIBUTE_NODE: Int = 2
pub val Attr::TEXT_NODE: Int = 3
pub val Attr::CDATA_SECTION_NODE: Int = 4
pub val Attr::ENTITY_REFERENCE_NODE: Int = 5
pub val Attr::ENTITY_NODE: Int = 6
pub val Attr::PROCESSING_INSTRUCTION_NODE: Int = 7
pub val Attr::COMMENT_NODE: Int = 8
pub val Attr::DOCUMENT_NODE: Int = 9
pub val Attr::DOCUMENT_TYPE_NODE: Int = 10
pub val Attr::DOCUMENT_FRAGMENT_NODE: Int = 11
pub val Attr::NOTATION_NODE: Int = 12
pub val Attr::DOCUMENT_POSITION_DISCONNECTED: Int = 1
pub val Attr::DOCUMENT_POSITION_PRECEDING: Int = 2
pub val Attr::DOCUMENT_POSITION_FOLLOWING: Int = 4
pub val Attr::DOCUMENT_POSITION_CONTAINS: Int = 8
pub val Attr::DOCUMENT_POSITION_CONTAINED_BY: Int = 16
pub val Attr::DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Int = 32

struct CharacterData()

/// Converts a reference to 'CharacterData' to a reference to 'Node'.
/// This does not involve manipulating the object or reference.
pub ext fun CharacterData::as_node(self: CharacterData) -> Node = "return #var(self);"

/// Converts a mutable reference to 'CharacterData' to a mutable reference to 'Node'.
/// This does not involve manipulating the object or reference.
pub ext fun CharacterData::as_mnode(self: mut CharacterData) -> mut Node = "return #var(self);"

/// Attempts to convert a reference to 'Node' to a reference to 'CharacterData'.
/// The conversion may fail and panic if 'base' is not a reference to 'CharacterData' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CharacterData::from_node(base: Node) -> CharacterData = "
    if(#var(base) instanceof CharacterData) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Node' to 'CharacterData'!\");
"

/// Attempts to convert a mutable reference to 'Node' to a mutable reference to 'CharacterData'.
/// The conversion may fail and panic if 'base' is not a reference to 'CharacterData' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CharacterData::from_mnode(base: mut Node) -> mut CharacterData = "
    if(#var(base) instanceof CharacterData) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Node' to 'CharacterData'!\");
"

/// Converts a reference to 'CharacterData' to a reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun CharacterData::as_event_target(self: CharacterData) -> EventTarget = "return #var(self);"

/// Converts a mutable reference to 'CharacterData' to a mutable reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun CharacterData::as_mevent_target(self: mut CharacterData) -> mut EventTarget = "return #var(self);"

/// Attempts to convert a reference to 'EventTarget' to a reference to 'CharacterData'.
/// The conversion may fail and panic if 'base' is not a reference to 'CharacterData' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CharacterData::from_event_target(base: EventTarget) -> CharacterData = "
    if(#var(base) instanceof CharacterData) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'CharacterData'!\");
"

/// Attempts to convert a mutable reference to 'EventTarget' to a mutable reference to 'CharacterData'.
/// The conversion may fail and panic if 'base' is not a reference to 'CharacterData' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CharacterData::from_mevent_target(base: mut EventTarget) -> mut CharacterData = "
    if(#var(base) instanceof CharacterData) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'CharacterData'!\");
"

pub ext fun CharacterData::data(self: CharacterData) -> String
    = "return #fun(String::from_js)(#var(self).data);"

pub ext fun CharacterData::set_data(self: mut CharacterData, value: String)
    = "#var(self).data = #fun(String::as_js)(#var(value));"

pub ext fun CharacterData::length(self: CharacterData) -> Int
    = "return #fun(Int::from_js)(#var(self).length);"

pub ext fun CharacterData::node_type(self: CharacterData) -> Int
    = "return #fun(Int::from_js)(#var(self).nodeType);"

pub ext fun CharacterData::node_name(self: CharacterData) -> String
    = "return #fun(String::from_js)(#var(self).nodeName);"

pub ext fun CharacterData::base_uri(self: CharacterData) -> String
    = "return #fun(String::from_js)(#var(self).baseURI);"

pub ext fun CharacterData::is_connected(self: CharacterData) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isConnected);"

pub ext fun CharacterData::owner_document(self: CharacterData) -> Option[mut Document]
    = "return #fun(Option::from_js[mut Document])(#var(self).ownerDocument);"

pub ext fun CharacterData::parent_node(self: CharacterData) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).parentNode);"

pub ext fun CharacterData::parent_element(self: CharacterData) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).parentElement);"

pub ext fun CharacterData::child_nodes(self: CharacterData) -> mut NodeList
    = "return #fun(NodeList::from_js)(#var(self).childNodes);"

pub ext fun CharacterData::first_child(self: CharacterData) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).firstChild);"

pub ext fun CharacterData::last_child(self: CharacterData) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).lastChild);"

pub ext fun CharacterData::previous_sibling(self: CharacterData) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).previousSibling);"

pub ext fun CharacterData::next_sibling(self: CharacterData) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).nextSibling);"

pub ext fun CharacterData::node_value(self: CharacterData) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).nodeValue);"

pub ext fun CharacterData::set_node_value(self: mut CharacterData, value: Option[String])
    = "#var(self).nodeValue = #fun(Option::as_js[String])(#var(value));"

pub ext fun CharacterData::text_content(self: CharacterData) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).textContent);"

pub ext fun CharacterData::set_text_content(self: mut CharacterData, value: Option[String])
    = "#var(self).textContent = #fun(Option::as_js[String])(#var(value));"

pub ext fun CharacterData::previous_element_sibling(self: CharacterData) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).previousElementSibling);"

pub ext fun CharacterData::next_element_sibling(self: CharacterData) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).nextElementSibling);"

pub ext fun CharacterData::substring_data(__self: mut CharacterData, offset: Int, count: Int) -> String = "
    const r = #var(__self).substringData(#fun(Int::as_js)(#var(offset)), #fun(Int::as_js)(#var(count)));
    return #fun(String::from_js)(r);
"

pub ext fun CharacterData::append_data(__self: mut CharacterData, data: String) -> Unit = "
    const r = #var(__self).appendData(#fun(String::as_js)(#var(data)));
    return #fun(Unit::from_js)(r);
"

pub ext fun CharacterData::insert_data(__self: mut CharacterData, offset: Int, data: String) -> Unit = "
    const r = #var(__self).insertData(#fun(Int::as_js)(#var(offset)), #fun(String::as_js)(#var(data)));
    return #fun(Unit::from_js)(r);
"

pub ext fun CharacterData::delete_data(__self: mut CharacterData, offset: Int, count: Int) -> Unit = "
    const r = #var(__self).deleteData(#fun(Int::as_js)(#var(offset)), #fun(Int::as_js)(#var(count)));
    return #fun(Unit::from_js)(r);
"

pub ext fun CharacterData::replace_data(__self: mut CharacterData, offset: Int, count: Int, data: String) -> Unit = "
    const r = #var(__self).replaceData(#fun(Int::as_js)(#var(offset)), #fun(Int::as_js)(#var(count)), #fun(String::as_js)(#var(data)));
    return #fun(Unit::from_js)(r);
"

pub ext fun CharacterData::get_root_node(__self: mut CharacterData, options: mut GetRootNodeOptions) -> mut Node = "
    const r = #var(__self).getRootNode(#fun(GetRootNodeOptions::as_js)(#var(options)));
    return #fun(Node::from_js)(r);
"

pub ext fun CharacterData::has_child_nodes(__self: mut CharacterData) -> Bool = "
    const r = #var(__self).hasChildNodes();
    return #fun(Bool::from_js)(r);
"

pub ext fun CharacterData::normalize(__self: mut CharacterData) -> Unit = "
    const r = #var(__self).normalize();
    return #fun(Unit::from_js)(r);
"

pub ext fun CharacterData::clone_node(__self: mut CharacterData, subtree: Bool) -> mut Node = "
    const r = #var(__self).cloneNode(#fun(Bool::as_js)(#var(subtree)));
    return #fun(Node::from_js)(r);
"

pub ext fun CharacterData::is_equal_node(__self: mut CharacterData, other_node: Option[mut Node]) -> Bool = "
    const r = #var(__self).isEqualNode(#fun(Option::as_js[mut Node])(#var(other_node)));
    return #fun(Bool::from_js)(r);
"

pub ext fun CharacterData::is_same_node(__self: mut CharacterData, other_node: Option[mut Node]) -> Bool = "
    const r = #var(__self).isSameNode(#fun(Option::as_js[mut Node])(#var(other_node)));
    return #fun(Bool::from_js)(r);
"

pub ext fun CharacterData::compare_document_position(__self: mut CharacterData, other: mut Node) -> Int = "
    const r = #var(__self).compareDocumentPosition(#fun(Node::as_js)(#var(other)));
    return #fun(Int::from_js)(r);
"

pub ext fun CharacterData::contains(__self: mut CharacterData, other: Option[mut Node]) -> Bool = "
    const r = #var(__self).contains(#fun(Option::as_js[mut Node])(#var(other)));
    return #fun(Bool::from_js)(r);
"

pub ext fun CharacterData::lookup_prefix(__self: mut CharacterData, namespace: Option[String]) -> Option[String] = "
    const r = #var(__self).lookupPrefix(#fun(Option::as_js[String])(#var(namespace)));
    return #fun(Option::from_js[String])(r);
"

pub ext fun CharacterData::lookup_namespace_uri(__self: mut CharacterData, prefix: Option[String]) -> Option[String] = "
    const r = #var(__self).lookupNamespaceURI(#fun(Option::as_js[String])(#var(prefix)));
    return #fun(Option::from_js[String])(r);
"

pub ext fun CharacterData::is_default_namespace(__self: mut CharacterData, namespace: Option[String]) -> Bool = "
    const r = #var(__self).isDefaultNamespace(#fun(Option::as_js[String])(#var(namespace)));
    return #fun(Bool::from_js)(r);
"

pub ext fun CharacterData::insert_before(__self: mut CharacterData, node: mut Node, child: Option[mut Node]) -> mut Node = "
    const r = #var(__self).insertBefore(#fun(Node::as_js)(#var(node)), #fun(Option::as_js[mut Node])(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun CharacterData::append_child(__self: mut CharacterData, node: mut Node) -> mut Node = "
    const r = #var(__self).appendChild(#fun(Node::as_js)(#var(node)));
    return #fun(Node::from_js)(r);
"

pub ext fun CharacterData::replace_child(__self: mut CharacterData, node: mut Node, child: mut Node) -> mut Node = "
    const r = #var(__self).replaceChild(#fun(Node::as_js)(#var(node)), #fun(Node::as_js)(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun CharacterData::remove_child(__self: mut CharacterData, child: mut Node) -> mut Node = "
    const r = #var(__self).removeChild(#fun(Node::as_js)(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun CharacterData::add_event_listener(__self: mut CharacterData, type: String, callback: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).addEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(callback)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun CharacterData::remove_event_listener(__self: mut CharacterData, type: String, callback: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).removeEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(callback)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun CharacterData::dispatch_event(__self: mut CharacterData, event: mut Event) -> Bool = "
    const r = #var(__self).dispatchEvent(#fun(Event::as_js)(#var(event)));
    return #fun(Bool::from_js)(r);
"

pub ext fun CharacterData::before(__self: mut CharacterData, ...nodes: List[JsValue]) -> Unit = "
    const r = #var(__self).before((#var(nodes)).map(v => v));
    return #fun(Unit::from_js)(r);
"

pub ext fun CharacterData::after(__self: mut CharacterData, ...nodes: List[JsValue]) -> Unit = "
    const r = #var(__self).after((#var(nodes)).map(v => v));
    return #fun(Unit::from_js)(r);
"

pub ext fun CharacterData::replace_with(__self: mut CharacterData, ...nodes: List[JsValue]) -> Unit = "
    const r = #var(__self).replaceWith((#var(nodes)).map(v => v));
    return #fun(Unit::from_js)(r);
"

pub ext fun CharacterData::remove(__self: mut CharacterData) -> Unit = "
    const r = #var(__self).remove();
    return #fun(Unit::from_js)(r);
"

pub fun CharacterData::as_js(self: CharacterData) -> JsValue = JsValue::unsafe_from[CharacterData](self)

pub fun CharacterData::from_js(v: JsValue) -> mut CharacterData = JsValue::unsafe_as[mut CharacterData](v)

pub val CharacterData::ELEMENT_NODE: Int = 1
pub val CharacterData::ATTRIBUTE_NODE: Int = 2
pub val CharacterData::TEXT_NODE: Int = 3
pub val CharacterData::CDATA_SECTION_NODE: Int = 4
pub val CharacterData::ENTITY_REFERENCE_NODE: Int = 5
pub val CharacterData::ENTITY_NODE: Int = 6
pub val CharacterData::PROCESSING_INSTRUCTION_NODE: Int = 7
pub val CharacterData::COMMENT_NODE: Int = 8
pub val CharacterData::DOCUMENT_NODE: Int = 9
pub val CharacterData::DOCUMENT_TYPE_NODE: Int = 10
pub val CharacterData::DOCUMENT_FRAGMENT_NODE: Int = 11
pub val CharacterData::NOTATION_NODE: Int = 12
pub val CharacterData::DOCUMENT_POSITION_DISCONNECTED: Int = 1
pub val CharacterData::DOCUMENT_POSITION_PRECEDING: Int = 2
pub val CharacterData::DOCUMENT_POSITION_FOLLOWING: Int = 4
pub val CharacterData::DOCUMENT_POSITION_CONTAINS: Int = 8
pub val CharacterData::DOCUMENT_POSITION_CONTAINED_BY: Int = 16
pub val CharacterData::DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Int = 32

struct Text()

/// Converts a reference to 'Text' to a reference to 'CharacterData'.
/// This does not involve manipulating the object or reference.
pub ext fun Text::as_character_data(self: Text) -> CharacterData = "return #var(self);"

/// Converts a mutable reference to 'Text' to a mutable reference to 'CharacterData'.
/// This does not involve manipulating the object or reference.
pub ext fun Text::as_mcharacter_data(self: mut Text) -> mut CharacterData = "return #var(self);"

/// Attempts to convert a reference to 'CharacterData' to a reference to 'Text'.
/// The conversion may fail and panic if 'base' is not a reference to 'Text' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Text::from_character_data(base: CharacterData) -> Text = "
    if(#var(base) instanceof Text) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CharacterData' to 'Text'!\");
"

/// Attempts to convert a mutable reference to 'CharacterData' to a mutable reference to 'Text'.
/// The conversion may fail and panic if 'base' is not a reference to 'Text' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Text::from_mcharacter_data(base: mut CharacterData) -> mut Text = "
    if(#var(base) instanceof Text) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CharacterData' to 'Text'!\");
"

/// Converts a reference to 'Text' to a reference to 'Node'.
/// This does not involve manipulating the object or reference.
pub ext fun Text::as_node(self: Text) -> Node = "return #var(self);"

/// Converts a mutable reference to 'Text' to a mutable reference to 'Node'.
/// This does not involve manipulating the object or reference.
pub ext fun Text::as_mnode(self: mut Text) -> mut Node = "return #var(self);"

/// Attempts to convert a reference to 'Node' to a reference to 'Text'.
/// The conversion may fail and panic if 'base' is not a reference to 'Text' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Text::from_node(base: Node) -> Text = "
    if(#var(base) instanceof Text) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Node' to 'Text'!\");
"

/// Attempts to convert a mutable reference to 'Node' to a mutable reference to 'Text'.
/// The conversion may fail and panic if 'base' is not a reference to 'Text' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Text::from_mnode(base: mut Node) -> mut Text = "
    if(#var(base) instanceof Text) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Node' to 'Text'!\");
"

/// Converts a reference to 'Text' to a reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun Text::as_event_target(self: Text) -> EventTarget = "return #var(self);"

/// Converts a mutable reference to 'Text' to a mutable reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun Text::as_mevent_target(self: mut Text) -> mut EventTarget = "return #var(self);"

/// Attempts to convert a reference to 'EventTarget' to a reference to 'Text'.
/// The conversion may fail and panic if 'base' is not a reference to 'Text' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Text::from_event_target(base: EventTarget) -> Text = "
    if(#var(base) instanceof Text) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'Text'!\");
"

/// Attempts to convert a mutable reference to 'EventTarget' to a mutable reference to 'Text'.
/// The conversion may fail and panic if 'base' is not a reference to 'Text' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Text::from_mevent_target(base: mut EventTarget) -> mut Text = "
    if(#var(base) instanceof Text) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'Text'!\");
"

pub ext fun Text::from_str(data: String) -> mut Text
    = "new Text(#fun(String::as_js)(#var(data)));"

pub ext fun Text::whole_text(self: Text) -> String
    = "return #fun(String::from_js)(#var(self).wholeText);"

pub ext fun Text::data(self: Text) -> String
    = "return #fun(String::from_js)(#var(self).data);"

pub ext fun Text::set_data(self: mut Text, value: String)
    = "#var(self).data = #fun(String::as_js)(#var(value));"

pub ext fun Text::length(self: Text) -> Int
    = "return #fun(Int::from_js)(#var(self).length);"

pub ext fun Text::node_type(self: Text) -> Int
    = "return #fun(Int::from_js)(#var(self).nodeType);"

pub ext fun Text::node_name(self: Text) -> String
    = "return #fun(String::from_js)(#var(self).nodeName);"

pub ext fun Text::base_uri(self: Text) -> String
    = "return #fun(String::from_js)(#var(self).baseURI);"

pub ext fun Text::is_connected(self: Text) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isConnected);"

pub ext fun Text::owner_document(self: Text) -> Option[mut Document]
    = "return #fun(Option::from_js[mut Document])(#var(self).ownerDocument);"

pub ext fun Text::parent_node(self: Text) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).parentNode);"

pub ext fun Text::parent_element(self: Text) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).parentElement);"

pub ext fun Text::child_nodes(self: Text) -> mut NodeList
    = "return #fun(NodeList::from_js)(#var(self).childNodes);"

pub ext fun Text::first_child(self: Text) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).firstChild);"

pub ext fun Text::last_child(self: Text) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).lastChild);"

pub ext fun Text::previous_sibling(self: Text) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).previousSibling);"

pub ext fun Text::next_sibling(self: Text) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).nextSibling);"

pub ext fun Text::node_value(self: Text) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).nodeValue);"

pub ext fun Text::set_node_value(self: mut Text, value: Option[String])
    = "#var(self).nodeValue = #fun(Option::as_js[String])(#var(value));"

pub ext fun Text::text_content(self: Text) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).textContent);"

pub ext fun Text::set_text_content(self: mut Text, value: Option[String])
    = "#var(self).textContent = #fun(Option::as_js[String])(#var(value));"

pub ext fun Text::assigned_slot(self: Text) -> Option[JsValue]
    = "return #fun(Option::from_js[JsValue])(#var(self).assignedSlot);"

pub ext fun Text::split_text(__self: mut Text, offset: Int) -> mut Text = "
    const r = #var(__self).splitText(#fun(Int::as_js)(#var(offset)));
    return #fun(Text::from_js)(r);
"

pub ext fun Text::substring_data(__self: mut Text, offset: Int, count: Int) -> String = "
    const r = #var(__self).substringData(#fun(Int::as_js)(#var(offset)), #fun(Int::as_js)(#var(count)));
    return #fun(String::from_js)(r);
"

pub ext fun Text::append_data(__self: mut Text, data: String) -> Unit = "
    const r = #var(__self).appendData(#fun(String::as_js)(#var(data)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Text::insert_data(__self: mut Text, offset: Int, data: String) -> Unit = "
    const r = #var(__self).insertData(#fun(Int::as_js)(#var(offset)), #fun(String::as_js)(#var(data)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Text::delete_data(__self: mut Text, offset: Int, count: Int) -> Unit = "
    const r = #var(__self).deleteData(#fun(Int::as_js)(#var(offset)), #fun(Int::as_js)(#var(count)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Text::replace_data(__self: mut Text, offset: Int, count: Int, data: String) -> Unit = "
    const r = #var(__self).replaceData(#fun(Int::as_js)(#var(offset)), #fun(Int::as_js)(#var(count)), #fun(String::as_js)(#var(data)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Text::get_root_node(__self: mut Text, options: mut GetRootNodeOptions) -> mut Node = "
    const r = #var(__self).getRootNode(#fun(GetRootNodeOptions::as_js)(#var(options)));
    return #fun(Node::from_js)(r);
"

pub ext fun Text::has_child_nodes(__self: mut Text) -> Bool = "
    const r = #var(__self).hasChildNodes();
    return #fun(Bool::from_js)(r);
"

pub ext fun Text::normalize(__self: mut Text) -> Unit = "
    const r = #var(__self).normalize();
    return #fun(Unit::from_js)(r);
"

pub ext fun Text::clone_node(__self: mut Text, subtree: Bool) -> mut Node = "
    const r = #var(__self).cloneNode(#fun(Bool::as_js)(#var(subtree)));
    return #fun(Node::from_js)(r);
"

pub ext fun Text::is_equal_node(__self: mut Text, other_node: Option[mut Node]) -> Bool = "
    const r = #var(__self).isEqualNode(#fun(Option::as_js[mut Node])(#var(other_node)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Text::is_same_node(__self: mut Text, other_node: Option[mut Node]) -> Bool = "
    const r = #var(__self).isSameNode(#fun(Option::as_js[mut Node])(#var(other_node)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Text::compare_document_position(__self: mut Text, other: mut Node) -> Int = "
    const r = #var(__self).compareDocumentPosition(#fun(Node::as_js)(#var(other)));
    return #fun(Int::from_js)(r);
"

pub ext fun Text::contains(__self: mut Text, other: Option[mut Node]) -> Bool = "
    const r = #var(__self).contains(#fun(Option::as_js[mut Node])(#var(other)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Text::lookup_prefix(__self: mut Text, namespace: Option[String]) -> Option[String] = "
    const r = #var(__self).lookupPrefix(#fun(Option::as_js[String])(#var(namespace)));
    return #fun(Option::from_js[String])(r);
"

pub ext fun Text::lookup_namespace_uri(__self: mut Text, prefix: Option[String]) -> Option[String] = "
    const r = #var(__self).lookupNamespaceURI(#fun(Option::as_js[String])(#var(prefix)));
    return #fun(Option::from_js[String])(r);
"

pub ext fun Text::is_default_namespace(__self: mut Text, namespace: Option[String]) -> Bool = "
    const r = #var(__self).isDefaultNamespace(#fun(Option::as_js[String])(#var(namespace)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Text::insert_before(__self: mut Text, node: mut Node, child: Option[mut Node]) -> mut Node = "
    const r = #var(__self).insertBefore(#fun(Node::as_js)(#var(node)), #fun(Option::as_js[mut Node])(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun Text::append_child(__self: mut Text, node: mut Node) -> mut Node = "
    const r = #var(__self).appendChild(#fun(Node::as_js)(#var(node)));
    return #fun(Node::from_js)(r);
"

pub ext fun Text::replace_child(__self: mut Text, node: mut Node, child: mut Node) -> mut Node = "
    const r = #var(__self).replaceChild(#fun(Node::as_js)(#var(node)), #fun(Node::as_js)(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun Text::remove_child(__self: mut Text, child: mut Node) -> mut Node = "
    const r = #var(__self).removeChild(#fun(Node::as_js)(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun Text::add_event_listener(__self: mut Text, type: String, callback: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).addEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(callback)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun Text::remove_event_listener(__self: mut Text, type: String, callback: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).removeEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(callback)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun Text::dispatch_event(__self: mut Text, event: mut Event) -> Bool = "
    const r = #var(__self).dispatchEvent(#fun(Event::as_js)(#var(event)));
    return #fun(Bool::from_js)(r);
"

pub fun Text::as_js(self: Text) -> JsValue = JsValue::unsafe_from[Text](self)

pub fun Text::from_js(v: JsValue) -> mut Text = JsValue::unsafe_as[mut Text](v)

pub val Text::ELEMENT_NODE: Int = 1
pub val Text::ATTRIBUTE_NODE: Int = 2
pub val Text::TEXT_NODE: Int = 3
pub val Text::CDATA_SECTION_NODE: Int = 4
pub val Text::ENTITY_REFERENCE_NODE: Int = 5
pub val Text::ENTITY_NODE: Int = 6
pub val Text::PROCESSING_INSTRUCTION_NODE: Int = 7
pub val Text::COMMENT_NODE: Int = 8
pub val Text::DOCUMENT_NODE: Int = 9
pub val Text::DOCUMENT_TYPE_NODE: Int = 10
pub val Text::DOCUMENT_FRAGMENT_NODE: Int = 11
pub val Text::NOTATION_NODE: Int = 12
pub val Text::DOCUMENT_POSITION_DISCONNECTED: Int = 1
pub val Text::DOCUMENT_POSITION_PRECEDING: Int = 2
pub val Text::DOCUMENT_POSITION_FOLLOWING: Int = 4
pub val Text::DOCUMENT_POSITION_CONTAINS: Int = 8
pub val Text::DOCUMENT_POSITION_CONTAINED_BY: Int = 16
pub val Text::DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Int = 32

struct CDATASection()

/// Converts a reference to 'CDATASection' to a reference to 'Text'.
/// This does not involve manipulating the object or reference.
pub ext fun CDATASection::as_text(self: CDATASection) -> Text = "return #var(self);"

/// Converts a mutable reference to 'CDATASection' to a mutable reference to 'Text'.
/// This does not involve manipulating the object or reference.
pub ext fun CDATASection::as_mtext(self: mut CDATASection) -> mut Text = "return #var(self);"

/// Attempts to convert a reference to 'Text' to a reference to 'CDATASection'.
/// The conversion may fail and panic if 'base' is not a reference to 'CDATASection' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CDATASection::from_text(base: Text) -> CDATASection = "
    if(#var(base) instanceof CDATASection) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Text' to 'CDATASection'!\");
"

/// Attempts to convert a mutable reference to 'Text' to a mutable reference to 'CDATASection'.
/// The conversion may fail and panic if 'base' is not a reference to 'CDATASection' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CDATASection::from_mtext(base: mut Text) -> mut CDATASection = "
    if(#var(base) instanceof CDATASection) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Text' to 'CDATASection'!\");
"

/// Converts a reference to 'CDATASection' to a reference to 'CharacterData'.
/// This does not involve manipulating the object or reference.
pub ext fun CDATASection::as_character_data(self: CDATASection) -> CharacterData = "return #var(self);"

/// Converts a mutable reference to 'CDATASection' to a mutable reference to 'CharacterData'.
/// This does not involve manipulating the object or reference.
pub ext fun CDATASection::as_mcharacter_data(self: mut CDATASection) -> mut CharacterData = "return #var(self);"

/// Attempts to convert a reference to 'CharacterData' to a reference to 'CDATASection'.
/// The conversion may fail and panic if 'base' is not a reference to 'CDATASection' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CDATASection::from_character_data(base: CharacterData) -> CDATASection = "
    if(#var(base) instanceof CDATASection) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CharacterData' to 'CDATASection'!\");
"

/// Attempts to convert a mutable reference to 'CharacterData' to a mutable reference to 'CDATASection'.
/// The conversion may fail and panic if 'base' is not a reference to 'CDATASection' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CDATASection::from_mcharacter_data(base: mut CharacterData) -> mut CDATASection = "
    if(#var(base) instanceof CDATASection) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CharacterData' to 'CDATASection'!\");
"

/// Converts a reference to 'CDATASection' to a reference to 'Node'.
/// This does not involve manipulating the object or reference.
pub ext fun CDATASection::as_node(self: CDATASection) -> Node = "return #var(self);"

/// Converts a mutable reference to 'CDATASection' to a mutable reference to 'Node'.
/// This does not involve manipulating the object or reference.
pub ext fun CDATASection::as_mnode(self: mut CDATASection) -> mut Node = "return #var(self);"

/// Attempts to convert a reference to 'Node' to a reference to 'CDATASection'.
/// The conversion may fail and panic if 'base' is not a reference to 'CDATASection' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CDATASection::from_node(base: Node) -> CDATASection = "
    if(#var(base) instanceof CDATASection) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Node' to 'CDATASection'!\");
"

/// Attempts to convert a mutable reference to 'Node' to a mutable reference to 'CDATASection'.
/// The conversion may fail and panic if 'base' is not a reference to 'CDATASection' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CDATASection::from_mnode(base: mut Node) -> mut CDATASection = "
    if(#var(base) instanceof CDATASection) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Node' to 'CDATASection'!\");
"

/// Converts a reference to 'CDATASection' to a reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun CDATASection::as_event_target(self: CDATASection) -> EventTarget = "return #var(self);"

/// Converts a mutable reference to 'CDATASection' to a mutable reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun CDATASection::as_mevent_target(self: mut CDATASection) -> mut EventTarget = "return #var(self);"

/// Attempts to convert a reference to 'EventTarget' to a reference to 'CDATASection'.
/// The conversion may fail and panic if 'base' is not a reference to 'CDATASection' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CDATASection::from_event_target(base: EventTarget) -> CDATASection = "
    if(#var(base) instanceof CDATASection) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'CDATASection'!\");
"

/// Attempts to convert a mutable reference to 'EventTarget' to a mutable reference to 'CDATASection'.
/// The conversion may fail and panic if 'base' is not a reference to 'CDATASection' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun CDATASection::from_mevent_target(base: mut EventTarget) -> mut CDATASection = "
    if(#var(base) instanceof CDATASection) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'CDATASection'!\");
"

pub ext fun CDATASection::whole_text(self: CDATASection) -> String
    = "return #fun(String::from_js)(#var(self).wholeText);"

pub ext fun CDATASection::data(self: CDATASection) -> String
    = "return #fun(String::from_js)(#var(self).data);"

pub ext fun CDATASection::set_data(self: mut CDATASection, value: String)
    = "#var(self).data = #fun(String::as_js)(#var(value));"

pub ext fun CDATASection::length(self: CDATASection) -> Int
    = "return #fun(Int::from_js)(#var(self).length);"

pub ext fun CDATASection::node_type(self: CDATASection) -> Int
    = "return #fun(Int::from_js)(#var(self).nodeType);"

pub ext fun CDATASection::node_name(self: CDATASection) -> String
    = "return #fun(String::from_js)(#var(self).nodeName);"

pub ext fun CDATASection::base_uri(self: CDATASection) -> String
    = "return #fun(String::from_js)(#var(self).baseURI);"

pub ext fun CDATASection::is_connected(self: CDATASection) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isConnected);"

pub ext fun CDATASection::owner_document(self: CDATASection) -> Option[mut Document]
    = "return #fun(Option::from_js[mut Document])(#var(self).ownerDocument);"

pub ext fun CDATASection::parent_node(self: CDATASection) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).parentNode);"

pub ext fun CDATASection::parent_element(self: CDATASection) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).parentElement);"

pub ext fun CDATASection::child_nodes(self: CDATASection) -> mut NodeList
    = "return #fun(NodeList::from_js)(#var(self).childNodes);"

pub ext fun CDATASection::first_child(self: CDATASection) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).firstChild);"

pub ext fun CDATASection::last_child(self: CDATASection) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).lastChild);"

pub ext fun CDATASection::previous_sibling(self: CDATASection) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).previousSibling);"

pub ext fun CDATASection::next_sibling(self: CDATASection) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).nextSibling);"

pub ext fun CDATASection::node_value(self: CDATASection) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).nodeValue);"

pub ext fun CDATASection::set_node_value(self: mut CDATASection, value: Option[String])
    = "#var(self).nodeValue = #fun(Option::as_js[String])(#var(value));"

pub ext fun CDATASection::text_content(self: CDATASection) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).textContent);"

pub ext fun CDATASection::set_text_content(self: mut CDATASection, value: Option[String])
    = "#var(self).textContent = #fun(Option::as_js[String])(#var(value));"

pub ext fun CDATASection::split_text(__self: mut CDATASection, offset: Int) -> mut Text = "
    const r = #var(__self).splitText(#fun(Int::as_js)(#var(offset)));
    return #fun(Text::from_js)(r);
"

pub ext fun CDATASection::substring_data(__self: mut CDATASection, offset: Int, count: Int) -> String = "
    const r = #var(__self).substringData(#fun(Int::as_js)(#var(offset)), #fun(Int::as_js)(#var(count)));
    return #fun(String::from_js)(r);
"

pub ext fun CDATASection::append_data(__self: mut CDATASection, data: String) -> Unit = "
    const r = #var(__self).appendData(#fun(String::as_js)(#var(data)));
    return #fun(Unit::from_js)(r);
"

pub ext fun CDATASection::insert_data(__self: mut CDATASection, offset: Int, data: String) -> Unit = "
    const r = #var(__self).insertData(#fun(Int::as_js)(#var(offset)), #fun(String::as_js)(#var(data)));
    return #fun(Unit::from_js)(r);
"

pub ext fun CDATASection::delete_data(__self: mut CDATASection, offset: Int, count: Int) -> Unit = "
    const r = #var(__self).deleteData(#fun(Int::as_js)(#var(offset)), #fun(Int::as_js)(#var(count)));
    return #fun(Unit::from_js)(r);
"

pub ext fun CDATASection::replace_data(__self: mut CDATASection, offset: Int, count: Int, data: String) -> Unit = "
    const r = #var(__self).replaceData(#fun(Int::as_js)(#var(offset)), #fun(Int::as_js)(#var(count)), #fun(String::as_js)(#var(data)));
    return #fun(Unit::from_js)(r);
"

pub ext fun CDATASection::get_root_node(__self: mut CDATASection, options: mut GetRootNodeOptions) -> mut Node = "
    const r = #var(__self).getRootNode(#fun(GetRootNodeOptions::as_js)(#var(options)));
    return #fun(Node::from_js)(r);
"

pub ext fun CDATASection::has_child_nodes(__self: mut CDATASection) -> Bool = "
    const r = #var(__self).hasChildNodes();
    return #fun(Bool::from_js)(r);
"

pub ext fun CDATASection::normalize(__self: mut CDATASection) -> Unit = "
    const r = #var(__self).normalize();
    return #fun(Unit::from_js)(r);
"

pub ext fun CDATASection::clone_node(__self: mut CDATASection, subtree: Bool) -> mut Node = "
    const r = #var(__self).cloneNode(#fun(Bool::as_js)(#var(subtree)));
    return #fun(Node::from_js)(r);
"

pub ext fun CDATASection::is_equal_node(__self: mut CDATASection, other_node: Option[mut Node]) -> Bool = "
    const r = #var(__self).isEqualNode(#fun(Option::as_js[mut Node])(#var(other_node)));
    return #fun(Bool::from_js)(r);
"

pub ext fun CDATASection::is_same_node(__self: mut CDATASection, other_node: Option[mut Node]) -> Bool = "
    const r = #var(__self).isSameNode(#fun(Option::as_js[mut Node])(#var(other_node)));
    return #fun(Bool::from_js)(r);
"

pub ext fun CDATASection::compare_document_position(__self: mut CDATASection, other: mut Node) -> Int = "
    const r = #var(__self).compareDocumentPosition(#fun(Node::as_js)(#var(other)));
    return #fun(Int::from_js)(r);
"

pub ext fun CDATASection::contains(__self: mut CDATASection, other: Option[mut Node]) -> Bool = "
    const r = #var(__self).contains(#fun(Option::as_js[mut Node])(#var(other)));
    return #fun(Bool::from_js)(r);
"

pub ext fun CDATASection::lookup_prefix(__self: mut CDATASection, namespace: Option[String]) -> Option[String] = "
    const r = #var(__self).lookupPrefix(#fun(Option::as_js[String])(#var(namespace)));
    return #fun(Option::from_js[String])(r);
"

pub ext fun CDATASection::lookup_namespace_uri(__self: mut CDATASection, prefix: Option[String]) -> Option[String] = "
    const r = #var(__self).lookupNamespaceURI(#fun(Option::as_js[String])(#var(prefix)));
    return #fun(Option::from_js[String])(r);
"

pub ext fun CDATASection::is_default_namespace(__self: mut CDATASection, namespace: Option[String]) -> Bool = "
    const r = #var(__self).isDefaultNamespace(#fun(Option::as_js[String])(#var(namespace)));
    return #fun(Bool::from_js)(r);
"

pub ext fun CDATASection::insert_before(__self: mut CDATASection, node: mut Node, child: Option[mut Node]) -> mut Node = "
    const r = #var(__self).insertBefore(#fun(Node::as_js)(#var(node)), #fun(Option::as_js[mut Node])(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun CDATASection::append_child(__self: mut CDATASection, node: mut Node) -> mut Node = "
    const r = #var(__self).appendChild(#fun(Node::as_js)(#var(node)));
    return #fun(Node::from_js)(r);
"

pub ext fun CDATASection::replace_child(__self: mut CDATASection, node: mut Node, child: mut Node) -> mut Node = "
    const r = #var(__self).replaceChild(#fun(Node::as_js)(#var(node)), #fun(Node::as_js)(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun CDATASection::remove_child(__self: mut CDATASection, child: mut Node) -> mut Node = "
    const r = #var(__self).removeChild(#fun(Node::as_js)(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun CDATASection::add_event_listener(__self: mut CDATASection, type: String, callback: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).addEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(callback)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun CDATASection::remove_event_listener(__self: mut CDATASection, type: String, callback: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).removeEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(callback)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun CDATASection::dispatch_event(__self: mut CDATASection, event: mut Event) -> Bool = "
    const r = #var(__self).dispatchEvent(#fun(Event::as_js)(#var(event)));
    return #fun(Bool::from_js)(r);
"

pub fun CDATASection::as_js(self: CDATASection) -> JsValue = JsValue::unsafe_from[CDATASection](self)

pub fun CDATASection::from_js(v: JsValue) -> mut CDATASection = JsValue::unsafe_as[mut CDATASection](v)

pub val CDATASection::ELEMENT_NODE: Int = 1
pub val CDATASection::ATTRIBUTE_NODE: Int = 2
pub val CDATASection::TEXT_NODE: Int = 3
pub val CDATASection::CDATA_SECTION_NODE: Int = 4
pub val CDATASection::ENTITY_REFERENCE_NODE: Int = 5
pub val CDATASection::ENTITY_NODE: Int = 6
pub val CDATASection::PROCESSING_INSTRUCTION_NODE: Int = 7
pub val CDATASection::COMMENT_NODE: Int = 8
pub val CDATASection::DOCUMENT_NODE: Int = 9
pub val CDATASection::DOCUMENT_TYPE_NODE: Int = 10
pub val CDATASection::DOCUMENT_FRAGMENT_NODE: Int = 11
pub val CDATASection::NOTATION_NODE: Int = 12
pub val CDATASection::DOCUMENT_POSITION_DISCONNECTED: Int = 1
pub val CDATASection::DOCUMENT_POSITION_PRECEDING: Int = 2
pub val CDATASection::DOCUMENT_POSITION_FOLLOWING: Int = 4
pub val CDATASection::DOCUMENT_POSITION_CONTAINS: Int = 8
pub val CDATASection::DOCUMENT_POSITION_CONTAINED_BY: Int = 16
pub val CDATASection::DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Int = 32

struct ProcessingInstruction()

/// Converts a reference to 'ProcessingInstruction' to a reference to 'CharacterData'.
/// This does not involve manipulating the object or reference.
pub ext fun ProcessingInstruction::as_character_data(self: ProcessingInstruction) -> CharacterData = "return #var(self);"

/// Converts a mutable reference to 'ProcessingInstruction' to a mutable reference to 'CharacterData'.
/// This does not involve manipulating the object or reference.
pub ext fun ProcessingInstruction::as_mcharacter_data(self: mut ProcessingInstruction) -> mut CharacterData = "return #var(self);"

/// Attempts to convert a reference to 'CharacterData' to a reference to 'ProcessingInstruction'.
/// The conversion may fail and panic if 'base' is not a reference to 'ProcessingInstruction' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun ProcessingInstruction::from_character_data(base: CharacterData) -> ProcessingInstruction = "
    if(#var(base) instanceof ProcessingInstruction) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CharacterData' to 'ProcessingInstruction'!\");
"

/// Attempts to convert a mutable reference to 'CharacterData' to a mutable reference to 'ProcessingInstruction'.
/// The conversion may fail and panic if 'base' is not a reference to 'ProcessingInstruction' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun ProcessingInstruction::from_mcharacter_data(base: mut CharacterData) -> mut ProcessingInstruction = "
    if(#var(base) instanceof ProcessingInstruction) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CharacterData' to 'ProcessingInstruction'!\");
"

/// Converts a reference to 'ProcessingInstruction' to a reference to 'Node'.
/// This does not involve manipulating the object or reference.
pub ext fun ProcessingInstruction::as_node(self: ProcessingInstruction) -> Node = "return #var(self);"

/// Converts a mutable reference to 'ProcessingInstruction' to a mutable reference to 'Node'.
/// This does not involve manipulating the object or reference.
pub ext fun ProcessingInstruction::as_mnode(self: mut ProcessingInstruction) -> mut Node = "return #var(self);"

/// Attempts to convert a reference to 'Node' to a reference to 'ProcessingInstruction'.
/// The conversion may fail and panic if 'base' is not a reference to 'ProcessingInstruction' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun ProcessingInstruction::from_node(base: Node) -> ProcessingInstruction = "
    if(#var(base) instanceof ProcessingInstruction) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Node' to 'ProcessingInstruction'!\");
"

/// Attempts to convert a mutable reference to 'Node' to a mutable reference to 'ProcessingInstruction'.
/// The conversion may fail and panic if 'base' is not a reference to 'ProcessingInstruction' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun ProcessingInstruction::from_mnode(base: mut Node) -> mut ProcessingInstruction = "
    if(#var(base) instanceof ProcessingInstruction) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Node' to 'ProcessingInstruction'!\");
"

/// Converts a reference to 'ProcessingInstruction' to a reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun ProcessingInstruction::as_event_target(self: ProcessingInstruction) -> EventTarget = "return #var(self);"

/// Converts a mutable reference to 'ProcessingInstruction' to a mutable reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun ProcessingInstruction::as_mevent_target(self: mut ProcessingInstruction) -> mut EventTarget = "return #var(self);"

/// Attempts to convert a reference to 'EventTarget' to a reference to 'ProcessingInstruction'.
/// The conversion may fail and panic if 'base' is not a reference to 'ProcessingInstruction' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun ProcessingInstruction::from_event_target(base: EventTarget) -> ProcessingInstruction = "
    if(#var(base) instanceof ProcessingInstruction) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'ProcessingInstruction'!\");
"

/// Attempts to convert a mutable reference to 'EventTarget' to a mutable reference to 'ProcessingInstruction'.
/// The conversion may fail and panic if 'base' is not a reference to 'ProcessingInstruction' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun ProcessingInstruction::from_mevent_target(base: mut EventTarget) -> mut ProcessingInstruction = "
    if(#var(base) instanceof ProcessingInstruction) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'ProcessingInstruction'!\");
"

pub ext fun ProcessingInstruction::target(self: ProcessingInstruction) -> String
    = "return #fun(String::from_js)(#var(self).target);"

pub ext fun ProcessingInstruction::data(self: ProcessingInstruction) -> String
    = "return #fun(String::from_js)(#var(self).data);"

pub ext fun ProcessingInstruction::set_data(self: mut ProcessingInstruction, value: String)
    = "#var(self).data = #fun(String::as_js)(#var(value));"

pub ext fun ProcessingInstruction::length(self: ProcessingInstruction) -> Int
    = "return #fun(Int::from_js)(#var(self).length);"

pub ext fun ProcessingInstruction::node_type(self: ProcessingInstruction) -> Int
    = "return #fun(Int::from_js)(#var(self).nodeType);"

pub ext fun ProcessingInstruction::node_name(self: ProcessingInstruction) -> String
    = "return #fun(String::from_js)(#var(self).nodeName);"

pub ext fun ProcessingInstruction::base_uri(self: ProcessingInstruction) -> String
    = "return #fun(String::from_js)(#var(self).baseURI);"

pub ext fun ProcessingInstruction::is_connected(self: ProcessingInstruction) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isConnected);"

pub ext fun ProcessingInstruction::owner_document(self: ProcessingInstruction) -> Option[mut Document]
    = "return #fun(Option::from_js[mut Document])(#var(self).ownerDocument);"

pub ext fun ProcessingInstruction::parent_node(self: ProcessingInstruction) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).parentNode);"

pub ext fun ProcessingInstruction::parent_element(self: ProcessingInstruction) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).parentElement);"

pub ext fun ProcessingInstruction::child_nodes(self: ProcessingInstruction) -> mut NodeList
    = "return #fun(NodeList::from_js)(#var(self).childNodes);"

pub ext fun ProcessingInstruction::first_child(self: ProcessingInstruction) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).firstChild);"

pub ext fun ProcessingInstruction::last_child(self: ProcessingInstruction) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).lastChild);"

pub ext fun ProcessingInstruction::previous_sibling(self: ProcessingInstruction) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).previousSibling);"

pub ext fun ProcessingInstruction::next_sibling(self: ProcessingInstruction) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).nextSibling);"

pub ext fun ProcessingInstruction::node_value(self: ProcessingInstruction) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).nodeValue);"

pub ext fun ProcessingInstruction::set_node_value(self: mut ProcessingInstruction, value: Option[String])
    = "#var(self).nodeValue = #fun(Option::as_js[String])(#var(value));"

pub ext fun ProcessingInstruction::text_content(self: ProcessingInstruction) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).textContent);"

pub ext fun ProcessingInstruction::set_text_content(self: mut ProcessingInstruction, value: Option[String])
    = "#var(self).textContent = #fun(Option::as_js[String])(#var(value));"

pub ext fun ProcessingInstruction::substring_data(__self: mut ProcessingInstruction, offset: Int, count: Int) -> String = "
    const r = #var(__self).substringData(#fun(Int::as_js)(#var(offset)), #fun(Int::as_js)(#var(count)));
    return #fun(String::from_js)(r);
"

pub ext fun ProcessingInstruction::append_data(__self: mut ProcessingInstruction, data: String) -> Unit = "
    const r = #var(__self).appendData(#fun(String::as_js)(#var(data)));
    return #fun(Unit::from_js)(r);
"

pub ext fun ProcessingInstruction::insert_data(__self: mut ProcessingInstruction, offset: Int, data: String) -> Unit = "
    const r = #var(__self).insertData(#fun(Int::as_js)(#var(offset)), #fun(String::as_js)(#var(data)));
    return #fun(Unit::from_js)(r);
"

pub ext fun ProcessingInstruction::delete_data(__self: mut ProcessingInstruction, offset: Int, count: Int) -> Unit = "
    const r = #var(__self).deleteData(#fun(Int::as_js)(#var(offset)), #fun(Int::as_js)(#var(count)));
    return #fun(Unit::from_js)(r);
"

pub ext fun ProcessingInstruction::replace_data(__self: mut ProcessingInstruction, offset: Int, count: Int, data: String) -> Unit = "
    const r = #var(__self).replaceData(#fun(Int::as_js)(#var(offset)), #fun(Int::as_js)(#var(count)), #fun(String::as_js)(#var(data)));
    return #fun(Unit::from_js)(r);
"

pub ext fun ProcessingInstruction::get_root_node(__self: mut ProcessingInstruction, options: mut GetRootNodeOptions) -> mut Node = "
    const r = #var(__self).getRootNode(#fun(GetRootNodeOptions::as_js)(#var(options)));
    return #fun(Node::from_js)(r);
"

pub ext fun ProcessingInstruction::has_child_nodes(__self: mut ProcessingInstruction) -> Bool = "
    const r = #var(__self).hasChildNodes();
    return #fun(Bool::from_js)(r);
"

pub ext fun ProcessingInstruction::normalize(__self: mut ProcessingInstruction) -> Unit = "
    const r = #var(__self).normalize();
    return #fun(Unit::from_js)(r);
"

pub ext fun ProcessingInstruction::clone_node(__self: mut ProcessingInstruction, subtree: Bool) -> mut Node = "
    const r = #var(__self).cloneNode(#fun(Bool::as_js)(#var(subtree)));
    return #fun(Node::from_js)(r);
"

pub ext fun ProcessingInstruction::is_equal_node(__self: mut ProcessingInstruction, other_node: Option[mut Node]) -> Bool = "
    const r = #var(__self).isEqualNode(#fun(Option::as_js[mut Node])(#var(other_node)));
    return #fun(Bool::from_js)(r);
"

pub ext fun ProcessingInstruction::is_same_node(__self: mut ProcessingInstruction, other_node: Option[mut Node]) -> Bool = "
    const r = #var(__self).isSameNode(#fun(Option::as_js[mut Node])(#var(other_node)));
    return #fun(Bool::from_js)(r);
"

pub ext fun ProcessingInstruction::compare_document_position(__self: mut ProcessingInstruction, other: mut Node) -> Int = "
    const r = #var(__self).compareDocumentPosition(#fun(Node::as_js)(#var(other)));
    return #fun(Int::from_js)(r);
"

pub ext fun ProcessingInstruction::contains(__self: mut ProcessingInstruction, other: Option[mut Node]) -> Bool = "
    const r = #var(__self).contains(#fun(Option::as_js[mut Node])(#var(other)));
    return #fun(Bool::from_js)(r);
"

pub ext fun ProcessingInstruction::lookup_prefix(__self: mut ProcessingInstruction, namespace: Option[String]) -> Option[String] = "
    const r = #var(__self).lookupPrefix(#fun(Option::as_js[String])(#var(namespace)));
    return #fun(Option::from_js[String])(r);
"

pub ext fun ProcessingInstruction::lookup_namespace_uri(__self: mut ProcessingInstruction, prefix: Option[String]) -> Option[String] = "
    const r = #var(__self).lookupNamespaceURI(#fun(Option::as_js[String])(#var(prefix)));
    return #fun(Option::from_js[String])(r);
"

pub ext fun ProcessingInstruction::is_default_namespace(__self: mut ProcessingInstruction, namespace: Option[String]) -> Bool = "
    const r = #var(__self).isDefaultNamespace(#fun(Option::as_js[String])(#var(namespace)));
    return #fun(Bool::from_js)(r);
"

pub ext fun ProcessingInstruction::insert_before(__self: mut ProcessingInstruction, node: mut Node, child: Option[mut Node]) -> mut Node = "
    const r = #var(__self).insertBefore(#fun(Node::as_js)(#var(node)), #fun(Option::as_js[mut Node])(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun ProcessingInstruction::append_child(__self: mut ProcessingInstruction, node: mut Node) -> mut Node = "
    const r = #var(__self).appendChild(#fun(Node::as_js)(#var(node)));
    return #fun(Node::from_js)(r);
"

pub ext fun ProcessingInstruction::replace_child(__self: mut ProcessingInstruction, node: mut Node, child: mut Node) -> mut Node = "
    const r = #var(__self).replaceChild(#fun(Node::as_js)(#var(node)), #fun(Node::as_js)(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun ProcessingInstruction::remove_child(__self: mut ProcessingInstruction, child: mut Node) -> mut Node = "
    const r = #var(__self).removeChild(#fun(Node::as_js)(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun ProcessingInstruction::add_event_listener(__self: mut ProcessingInstruction, type: String, callback: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).addEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(callback)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun ProcessingInstruction::remove_event_listener(__self: mut ProcessingInstruction, type: String, callback: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).removeEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(callback)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun ProcessingInstruction::dispatch_event(__self: mut ProcessingInstruction, event: mut Event) -> Bool = "
    const r = #var(__self).dispatchEvent(#fun(Event::as_js)(#var(event)));
    return #fun(Bool::from_js)(r);
"

pub fun ProcessingInstruction::as_js(self: ProcessingInstruction) -> JsValue = JsValue::unsafe_from[ProcessingInstruction](self)

pub fun ProcessingInstruction::from_js(v: JsValue) -> mut ProcessingInstruction = JsValue::unsafe_as[mut ProcessingInstruction](v)

pub val ProcessingInstruction::ELEMENT_NODE: Int = 1
pub val ProcessingInstruction::ATTRIBUTE_NODE: Int = 2
pub val ProcessingInstruction::TEXT_NODE: Int = 3
pub val ProcessingInstruction::CDATA_SECTION_NODE: Int = 4
pub val ProcessingInstruction::ENTITY_REFERENCE_NODE: Int = 5
pub val ProcessingInstruction::ENTITY_NODE: Int = 6
pub val ProcessingInstruction::PROCESSING_INSTRUCTION_NODE: Int = 7
pub val ProcessingInstruction::COMMENT_NODE: Int = 8
pub val ProcessingInstruction::DOCUMENT_NODE: Int = 9
pub val ProcessingInstruction::DOCUMENT_TYPE_NODE: Int = 10
pub val ProcessingInstruction::DOCUMENT_FRAGMENT_NODE: Int = 11
pub val ProcessingInstruction::NOTATION_NODE: Int = 12
pub val ProcessingInstruction::DOCUMENT_POSITION_DISCONNECTED: Int = 1
pub val ProcessingInstruction::DOCUMENT_POSITION_PRECEDING: Int = 2
pub val ProcessingInstruction::DOCUMENT_POSITION_FOLLOWING: Int = 4
pub val ProcessingInstruction::DOCUMENT_POSITION_CONTAINS: Int = 8
pub val ProcessingInstruction::DOCUMENT_POSITION_CONTAINED_BY: Int = 16
pub val ProcessingInstruction::DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Int = 32

struct Comment()

/// Converts a reference to 'Comment' to a reference to 'CharacterData'.
/// This does not involve manipulating the object or reference.
pub ext fun Comment::as_character_data(self: Comment) -> CharacterData = "return #var(self);"

/// Converts a mutable reference to 'Comment' to a mutable reference to 'CharacterData'.
/// This does not involve manipulating the object or reference.
pub ext fun Comment::as_mcharacter_data(self: mut Comment) -> mut CharacterData = "return #var(self);"

/// Attempts to convert a reference to 'CharacterData' to a reference to 'Comment'.
/// The conversion may fail and panic if 'base' is not a reference to 'Comment' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Comment::from_character_data(base: CharacterData) -> Comment = "
    if(#var(base) instanceof Comment) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CharacterData' to 'Comment'!\");
"

/// Attempts to convert a mutable reference to 'CharacterData' to a mutable reference to 'Comment'.
/// The conversion may fail and panic if 'base' is not a reference to 'Comment' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Comment::from_mcharacter_data(base: mut CharacterData) -> mut Comment = "
    if(#var(base) instanceof Comment) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'CharacterData' to 'Comment'!\");
"

/// Converts a reference to 'Comment' to a reference to 'Node'.
/// This does not involve manipulating the object or reference.
pub ext fun Comment::as_node(self: Comment) -> Node = "return #var(self);"

/// Converts a mutable reference to 'Comment' to a mutable reference to 'Node'.
/// This does not involve manipulating the object or reference.
pub ext fun Comment::as_mnode(self: mut Comment) -> mut Node = "return #var(self);"

/// Attempts to convert a reference to 'Node' to a reference to 'Comment'.
/// The conversion may fail and panic if 'base' is not a reference to 'Comment' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Comment::from_node(base: Node) -> Comment = "
    if(#var(base) instanceof Comment) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Node' to 'Comment'!\");
"

/// Attempts to convert a mutable reference to 'Node' to a mutable reference to 'Comment'.
/// The conversion may fail and panic if 'base' is not a reference to 'Comment' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Comment::from_mnode(base: mut Node) -> mut Comment = "
    if(#var(base) instanceof Comment) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'Node' to 'Comment'!\");
"

/// Converts a reference to 'Comment' to a reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun Comment::as_event_target(self: Comment) -> EventTarget = "return #var(self);"

/// Converts a mutable reference to 'Comment' to a mutable reference to 'EventTarget'.
/// This does not involve manipulating the object or reference.
pub ext fun Comment::as_mevent_target(self: mut Comment) -> mut EventTarget = "return #var(self);"

/// Attempts to convert a reference to 'EventTarget' to a reference to 'Comment'.
/// The conversion may fail and panic if 'base' is not a reference to 'Comment' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Comment::from_event_target(base: EventTarget) -> Comment = "
    if(#var(base) instanceof Comment) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'Comment'!\");
"

/// Attempts to convert a mutable reference to 'EventTarget' to a mutable reference to 'Comment'.
/// The conversion may fail and panic if 'base' is not a reference to 'Comment' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Comment::from_mevent_target(base: mut EventTarget) -> mut Comment = "
    if(#var(base) instanceof Comment) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'EventTarget' to 'Comment'!\");
"

pub ext fun Comment::from_str(data: String) -> mut Comment
    = "new Comment(#fun(String::as_js)(#var(data)));"

pub ext fun Comment::data(self: Comment) -> String
    = "return #fun(String::from_js)(#var(self).data);"

pub ext fun Comment::set_data(self: mut Comment, value: String)
    = "#var(self).data = #fun(String::as_js)(#var(value));"

pub ext fun Comment::length(self: Comment) -> Int
    = "return #fun(Int::from_js)(#var(self).length);"

pub ext fun Comment::node_type(self: Comment) -> Int
    = "return #fun(Int::from_js)(#var(self).nodeType);"

pub ext fun Comment::node_name(self: Comment) -> String
    = "return #fun(String::from_js)(#var(self).nodeName);"

pub ext fun Comment::base_uri(self: Comment) -> String
    = "return #fun(String::from_js)(#var(self).baseURI);"

pub ext fun Comment::is_connected(self: Comment) -> Bool
    = "return #fun(Bool::from_js)(#var(self).isConnected);"

pub ext fun Comment::owner_document(self: Comment) -> Option[mut Document]
    = "return #fun(Option::from_js[mut Document])(#var(self).ownerDocument);"

pub ext fun Comment::parent_node(self: Comment) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).parentNode);"

pub ext fun Comment::parent_element(self: Comment) -> Option[mut Element]
    = "return #fun(Option::from_js[mut Element])(#var(self).parentElement);"

pub ext fun Comment::child_nodes(self: Comment) -> mut NodeList
    = "return #fun(NodeList::from_js)(#var(self).childNodes);"

pub ext fun Comment::first_child(self: Comment) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).firstChild);"

pub ext fun Comment::last_child(self: Comment) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).lastChild);"

pub ext fun Comment::previous_sibling(self: Comment) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).previousSibling);"

pub ext fun Comment::next_sibling(self: Comment) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).nextSibling);"

pub ext fun Comment::node_value(self: Comment) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).nodeValue);"

pub ext fun Comment::set_node_value(self: mut Comment, value: Option[String])
    = "#var(self).nodeValue = #fun(Option::as_js[String])(#var(value));"

pub ext fun Comment::text_content(self: Comment) -> Option[String]
    = "return #fun(Option::from_js[String])(#var(self).textContent);"

pub ext fun Comment::set_text_content(self: mut Comment, value: Option[String])
    = "#var(self).textContent = #fun(Option::as_js[String])(#var(value));"

pub ext fun Comment::substring_data(__self: mut Comment, offset: Int, count: Int) -> String = "
    const r = #var(__self).substringData(#fun(Int::as_js)(#var(offset)), #fun(Int::as_js)(#var(count)));
    return #fun(String::from_js)(r);
"

pub ext fun Comment::append_data(__self: mut Comment, data: String) -> Unit = "
    const r = #var(__self).appendData(#fun(String::as_js)(#var(data)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Comment::insert_data(__self: mut Comment, offset: Int, data: String) -> Unit = "
    const r = #var(__self).insertData(#fun(Int::as_js)(#var(offset)), #fun(String::as_js)(#var(data)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Comment::delete_data(__self: mut Comment, offset: Int, count: Int) -> Unit = "
    const r = #var(__self).deleteData(#fun(Int::as_js)(#var(offset)), #fun(Int::as_js)(#var(count)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Comment::replace_data(__self: mut Comment, offset: Int, count: Int, data: String) -> Unit = "
    const r = #var(__self).replaceData(#fun(Int::as_js)(#var(offset)), #fun(Int::as_js)(#var(count)), #fun(String::as_js)(#var(data)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Comment::get_root_node(__self: mut Comment, options: mut GetRootNodeOptions) -> mut Node = "
    const r = #var(__self).getRootNode(#fun(GetRootNodeOptions::as_js)(#var(options)));
    return #fun(Node::from_js)(r);
"

pub ext fun Comment::has_child_nodes(__self: mut Comment) -> Bool = "
    const r = #var(__self).hasChildNodes();
    return #fun(Bool::from_js)(r);
"

pub ext fun Comment::normalize(__self: mut Comment) -> Unit = "
    const r = #var(__self).normalize();
    return #fun(Unit::from_js)(r);
"

pub ext fun Comment::clone_node(__self: mut Comment, subtree: Bool) -> mut Node = "
    const r = #var(__self).cloneNode(#fun(Bool::as_js)(#var(subtree)));
    return #fun(Node::from_js)(r);
"

pub ext fun Comment::is_equal_node(__self: mut Comment, other_node: Option[mut Node]) -> Bool = "
    const r = #var(__self).isEqualNode(#fun(Option::as_js[mut Node])(#var(other_node)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Comment::is_same_node(__self: mut Comment, other_node: Option[mut Node]) -> Bool = "
    const r = #var(__self).isSameNode(#fun(Option::as_js[mut Node])(#var(other_node)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Comment::compare_document_position(__self: mut Comment, other: mut Node) -> Int = "
    const r = #var(__self).compareDocumentPosition(#fun(Node::as_js)(#var(other)));
    return #fun(Int::from_js)(r);
"

pub ext fun Comment::contains(__self: mut Comment, other: Option[mut Node]) -> Bool = "
    const r = #var(__self).contains(#fun(Option::as_js[mut Node])(#var(other)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Comment::lookup_prefix(__self: mut Comment, namespace: Option[String]) -> Option[String] = "
    const r = #var(__self).lookupPrefix(#fun(Option::as_js[String])(#var(namespace)));
    return #fun(Option::from_js[String])(r);
"

pub ext fun Comment::lookup_namespace_uri(__self: mut Comment, prefix: Option[String]) -> Option[String] = "
    const r = #var(__self).lookupNamespaceURI(#fun(Option::as_js[String])(#var(prefix)));
    return #fun(Option::from_js[String])(r);
"

pub ext fun Comment::is_default_namespace(__self: mut Comment, namespace: Option[String]) -> Bool = "
    const r = #var(__self).isDefaultNamespace(#fun(Option::as_js[String])(#var(namespace)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Comment::insert_before(__self: mut Comment, node: mut Node, child: Option[mut Node]) -> mut Node = "
    const r = #var(__self).insertBefore(#fun(Node::as_js)(#var(node)), #fun(Option::as_js[mut Node])(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun Comment::append_child(__self: mut Comment, node: mut Node) -> mut Node = "
    const r = #var(__self).appendChild(#fun(Node::as_js)(#var(node)));
    return #fun(Node::from_js)(r);
"

pub ext fun Comment::replace_child(__self: mut Comment, node: mut Node, child: mut Node) -> mut Node = "
    const r = #var(__self).replaceChild(#fun(Node::as_js)(#var(node)), #fun(Node::as_js)(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun Comment::remove_child(__self: mut Comment, child: mut Node) -> mut Node = "
    const r = #var(__self).removeChild(#fun(Node::as_js)(#var(child)));
    return #fun(Node::from_js)(r);
"

pub ext fun Comment::add_event_listener(__self: mut Comment, type: String, callback: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).addEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(callback)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun Comment::remove_event_listener(__self: mut Comment, type: String, callback: Option[Fun(mut Event) -> Unit], options: JsValue) -> Unit = "
    const r = #var(__self).removeEventListener(#fun(String::as_js)(#var(type)), #fun(Option::as_js[Fun(mut Event) -> Unit])(#var(callback)), #var(options));
    return #fun(Unit::from_js)(r);
"

pub ext fun Comment::dispatch_event(__self: mut Comment, event: mut Event) -> Bool = "
    const r = #var(__self).dispatchEvent(#fun(Event::as_js)(#var(event)));
    return #fun(Bool::from_js)(r);
"

pub fun Comment::as_js(self: Comment) -> JsValue = JsValue::unsafe_from[Comment](self)

pub fun Comment::from_js(v: JsValue) -> mut Comment = JsValue::unsafe_as[mut Comment](v)

pub val Comment::ELEMENT_NODE: Int = 1
pub val Comment::ATTRIBUTE_NODE: Int = 2
pub val Comment::TEXT_NODE: Int = 3
pub val Comment::CDATA_SECTION_NODE: Int = 4
pub val Comment::ENTITY_REFERENCE_NODE: Int = 5
pub val Comment::ENTITY_NODE: Int = 6
pub val Comment::PROCESSING_INSTRUCTION_NODE: Int = 7
pub val Comment::COMMENT_NODE: Int = 8
pub val Comment::DOCUMENT_NODE: Int = 9
pub val Comment::DOCUMENT_TYPE_NODE: Int = 10
pub val Comment::DOCUMENT_FRAGMENT_NODE: Int = 11
pub val Comment::NOTATION_NODE: Int = 12
pub val Comment::DOCUMENT_POSITION_DISCONNECTED: Int = 1
pub val Comment::DOCUMENT_POSITION_PRECEDING: Int = 2
pub val Comment::DOCUMENT_POSITION_FOLLOWING: Int = 4
pub val Comment::DOCUMENT_POSITION_CONTAINS: Int = 8
pub val Comment::DOCUMENT_POSITION_CONTAINED_BY: Int = 16
pub val Comment::DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Int = 32

struct AbstractRange()

pub ext fun AbstractRange::start_container(self: AbstractRange) -> mut Node
    = "return #fun(Node::from_js)(#var(self).startContainer);"

pub ext fun AbstractRange::start_offset(self: AbstractRange) -> Int
    = "return #fun(Int::from_js)(#var(self).startOffset);"

pub ext fun AbstractRange::end_container(self: AbstractRange) -> mut Node
    = "return #fun(Node::from_js)(#var(self).endContainer);"

pub ext fun AbstractRange::end_offset(self: AbstractRange) -> Int
    = "return #fun(Int::from_js)(#var(self).endOffset);"

pub ext fun AbstractRange::collapsed(self: AbstractRange) -> Bool
    = "return #fun(Bool::from_js)(#var(self).collapsed);"

pub fun AbstractRange::as_js(self: AbstractRange) -> JsValue = JsValue::unsafe_from[AbstractRange](self)

pub fun AbstractRange::from_js(v: JsValue) -> mut AbstractRange = JsValue::unsafe_as[mut AbstractRange](v)

pub struct StaticRangeInit(
    start_container: mut Node,
    start_offset: Int,
    end_container: mut Node,
    end_offset: Int
)

pub fun StaticRangeInit::default(start_container: mut Node, start_offset: Int, end_container: mut Node, end_offset: Int) -> mut StaticRangeInit
    = StaticRangeInit(start_container, start_offset, end_container, end_offset)

pub ext fun StaticRangeInit::from_js(value: JsValue) -> mut StaticRangeInit = "
    const r = {};
    r.start_container = #fun(Node::from_js)(#var(value).startContainer);
    r.start_offset = #fun(Int::from_js)(#var(value).startOffset);
    r.end_container = #fun(Node::from_js)(#var(value).endContainer);
    r.end_offset = #fun(Int::from_js)(#var(value).endOffset);
    return r;
"

pub ext fun StaticRangeInit::as_js(self: StaticRangeInit) -> JsValue = "
    const r = {};
    r.startContainer = #fun(Node::as_js)(#var(self).start_container);
    r.startOffset = #fun(Int::as_js)(#var(self).start_offset);
    r.endContainer = #fun(Node::as_js)(#var(self).end_container);
    r.endOffset = #fun(Int::as_js)(#var(self).end_offset);
    return r;
"

struct StaticRange()

/// Converts a reference to 'StaticRange' to a reference to 'AbstractRange'.
/// This does not involve manipulating the object or reference.
pub ext fun StaticRange::as_abstract_range(self: StaticRange) -> AbstractRange = "return #var(self);"

/// Converts a mutable reference to 'StaticRange' to a mutable reference to 'AbstractRange'.
/// This does not involve manipulating the object or reference.
pub ext fun StaticRange::as_mabstract_range(self: mut StaticRange) -> mut AbstractRange = "return #var(self);"

/// Attempts to convert a reference to 'AbstractRange' to a reference to 'StaticRange'.
/// The conversion may fail and panic if 'base' is not a reference to 'StaticRange' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun StaticRange::from_abstract_range(base: AbstractRange) -> StaticRange = "
    if(#var(base) instanceof StaticRange) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'AbstractRange' to 'StaticRange'!\");
"

/// Attempts to convert a mutable reference to 'AbstractRange' to a mutable reference to 'StaticRange'.
/// The conversion may fail and panic if 'base' is not a reference to 'StaticRange' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun StaticRange::from_mabstract_range(base: mut AbstractRange) -> mut StaticRange = "
    if(#var(base) instanceof StaticRange) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'AbstractRange' to 'StaticRange'!\");
"

pub ext fun StaticRange::from_mstatic_range_init(init: mut StaticRangeInit) -> mut StaticRange
    = "new StaticRange(#fun(StaticRangeInit::as_js)(#var(init)));"

pub ext fun StaticRange::start_container(self: StaticRange) -> mut Node
    = "return #fun(Node::from_js)(#var(self).startContainer);"

pub ext fun StaticRange::start_offset(self: StaticRange) -> Int
    = "return #fun(Int::from_js)(#var(self).startOffset);"

pub ext fun StaticRange::end_container(self: StaticRange) -> mut Node
    = "return #fun(Node::from_js)(#var(self).endContainer);"

pub ext fun StaticRange::end_offset(self: StaticRange) -> Int
    = "return #fun(Int::from_js)(#var(self).endOffset);"

pub ext fun StaticRange::collapsed(self: StaticRange) -> Bool
    = "return #fun(Bool::from_js)(#var(self).collapsed);"

pub fun StaticRange::as_js(self: StaticRange) -> JsValue = JsValue::unsafe_from[StaticRange](self)

pub fun StaticRange::from_js(v: JsValue) -> mut StaticRange = JsValue::unsafe_as[mut StaticRange](v)

struct Range()

/// Converts a reference to 'Range' to a reference to 'AbstractRange'.
/// This does not involve manipulating the object or reference.
pub ext fun Range::as_abstract_range(self: Range) -> AbstractRange = "return #var(self);"

/// Converts a mutable reference to 'Range' to a mutable reference to 'AbstractRange'.
/// This does not involve manipulating the object or reference.
pub ext fun Range::as_mabstract_range(self: mut Range) -> mut AbstractRange = "return #var(self);"

/// Attempts to convert a reference to 'AbstractRange' to a reference to 'Range'.
/// The conversion may fail and panic if 'base' is not a reference to 'Range' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Range::from_abstract_range(base: AbstractRange) -> Range = "
    if(#var(base) instanceof Range) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'AbstractRange' to 'Range'!\");
"

/// Attempts to convert a mutable reference to 'AbstractRange' to a mutable reference to 'Range'.
/// The conversion may fail and panic if 'base' is not a reference to 'Range' or if the given instance is user-implemented.
/// This does not involve manipulating the object or reference.
pub ext fun Range::from_mabstract_range(base: mut AbstractRange) -> mut Range = "
    if(#var(base) instanceof Range) { return #var(base); }
    #fun(panic[Unit])(\"Failed to downcast 'AbstractRange' to 'Range'!\");
"

pub ext fun Range::new() -> mut Range
    = "new Range();"

pub ext fun Range::common_ancestor_container(self: Range) -> mut Node
    = "return #fun(Node::from_js)(#var(self).commonAncestorContainer);"

pub ext fun Range::start_container(self: Range) -> mut Node
    = "return #fun(Node::from_js)(#var(self).startContainer);"

pub ext fun Range::start_offset(self: Range) -> Int
    = "return #fun(Int::from_js)(#var(self).startOffset);"

pub ext fun Range::end_container(self: Range) -> mut Node
    = "return #fun(Node::from_js)(#var(self).endContainer);"

pub ext fun Range::end_offset(self: Range) -> Int
    = "return #fun(Int::from_js)(#var(self).endOffset);"

pub ext fun Range::collapsed(self: Range) -> Bool
    = "return #fun(Bool::from_js)(#var(self).collapsed);"

pub ext fun Range::set_start(__self: mut Range, node: mut Node, offset: Int) -> Unit = "
    const r = #var(__self).setStart(#fun(Node::as_js)(#var(node)), #fun(Int::as_js)(#var(offset)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Range::set_end(__self: mut Range, node: mut Node, offset: Int) -> Unit = "
    const r = #var(__self).setEnd(#fun(Node::as_js)(#var(node)), #fun(Int::as_js)(#var(offset)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Range::set_start_before(__self: mut Range, node: mut Node) -> Unit = "
    const r = #var(__self).setStartBefore(#fun(Node::as_js)(#var(node)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Range::set_start_after(__self: mut Range, node: mut Node) -> Unit = "
    const r = #var(__self).setStartAfter(#fun(Node::as_js)(#var(node)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Range::set_end_before(__self: mut Range, node: mut Node) -> Unit = "
    const r = #var(__self).setEndBefore(#fun(Node::as_js)(#var(node)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Range::set_end_after(__self: mut Range, node: mut Node) -> Unit = "
    const r = #var(__self).setEndAfter(#fun(Node::as_js)(#var(node)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Range::collapse(__self: mut Range, to_start: Bool) -> Unit = "
    const r = #var(__self).collapse(#fun(Bool::as_js)(#var(to_start)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Range::select_node(__self: mut Range, node: mut Node) -> Unit = "
    const r = #var(__self).selectNode(#fun(Node::as_js)(#var(node)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Range::select_node_contents(__self: mut Range, node: mut Node) -> Unit = "
    const r = #var(__self).selectNodeContents(#fun(Node::as_js)(#var(node)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Range::compare_boundary_points(__self: mut Range, how: Int, source_range: mut Range) -> Int = "
    const r = #var(__self).compareBoundaryPoints(#fun(Int::as_js)(#var(how)), #fun(Range::as_js)(#var(source_range)));
    return #fun(Int::from_js)(r);
"

pub ext fun Range::delete_contents(__self: mut Range) -> Unit = "
    const r = #var(__self).deleteContents();
    return #fun(Unit::from_js)(r);
"

pub ext fun Range::extract_contents(__self: mut Range) -> mut DocumentFragment = "
    const r = #var(__self).extractContents();
    return #fun(DocumentFragment::from_js)(r);
"

pub ext fun Range::clone_contents(__self: mut Range) -> mut DocumentFragment = "
    const r = #var(__self).cloneContents();
    return #fun(DocumentFragment::from_js)(r);
"

pub ext fun Range::insert_node(__self: mut Range, node: mut Node) -> Unit = "
    const r = #var(__self).insertNode(#fun(Node::as_js)(#var(node)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Range::surround_contents(__self: mut Range, new_parent: mut Node) -> Unit = "
    const r = #var(__self).surroundContents(#fun(Node::as_js)(#var(new_parent)));
    return #fun(Unit::from_js)(r);
"

pub ext fun Range::clone_range(__self: mut Range) -> mut Range = "
    const r = #var(__self).cloneRange();
    return #fun(Range::from_js)(r);
"

pub ext fun Range::detach(__self: mut Range) -> Unit = "
    const r = #var(__self).detach();
    return #fun(Unit::from_js)(r);
"

pub ext fun Range::is_point_in_range(__self: mut Range, node: mut Node, offset: Int) -> Bool = "
    const r = #var(__self).isPointInRange(#fun(Node::as_js)(#var(node)), #fun(Int::as_js)(#var(offset)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Range::compare_point(__self: mut Range, node: mut Node, offset: Int) -> Int = "
    const r = #var(__self).comparePoint(#fun(Node::as_js)(#var(node)), #fun(Int::as_js)(#var(offset)));
    return #fun(Int::from_js)(r);
"

pub ext fun Range::intersects_node(__self: mut Range, node: mut Node) -> Bool = "
    const r = #var(__self).intersectsNode(#fun(Node::as_js)(#var(node)));
    return #fun(Bool::from_js)(r);
"

pub ext fun Range::as_string(__self: mut Range) -> String = "
    const r = #var(__self).toString();
    return r;
"

pub fun Range::as_js(self: Range) -> JsValue = JsValue::unsafe_from[Range](self)

pub fun Range::from_js(v: JsValue) -> mut Range = JsValue::unsafe_as[mut Range](v)

pub val Range::START_TO_START: Int = 0
pub val Range::START_TO_END: Int = 1
pub val Range::END_TO_END: Int = 2
pub val Range::END_TO_START: Int = 3

struct NodeIterator()

pub ext fun NodeIterator::root(self: NodeIterator) -> mut Node
    = "return #fun(Node::from_js)(#var(self).root);"

pub ext fun NodeIterator::reference_node(self: NodeIterator) -> mut Node
    = "return #fun(Node::from_js)(#var(self).referenceNode);"

pub ext fun NodeIterator::pointer_before_reference_node(self: NodeIterator) -> Bool
    = "return #fun(Bool::from_js)(#var(self).pointerBeforeReferenceNode);"

pub ext fun NodeIterator::what_to_show(self: NodeIterator) -> Int
    = "return #fun(Int::from_js)(#var(self).whatToShow);"

pub ext fun NodeIterator::filter(self: NodeIterator) -> Option[Fun(mut Node) -> Int]
    = "return #fun(Option::from_js[Fun(mut Node) -> Int])(#var(self).filter);"

pub ext fun NodeIterator::next_node(__self: mut NodeIterator) -> Option[mut Node] = "
    const r = #var(__self).nextNode();
    return #fun(Option::from_js[mut Node])(r);
"

pub ext fun NodeIterator::previous_node(__self: mut NodeIterator) -> Option[mut Node] = "
    const r = #var(__self).previousNode();
    return #fun(Option::from_js[mut Node])(r);
"

pub ext fun NodeIterator::detach(__self: mut NodeIterator) -> Unit = "
    const r = #var(__self).detach();
    return #fun(Unit::from_js)(r);
"

pub fun NodeIterator::as_js(self: NodeIterator) -> JsValue = JsValue::unsafe_from[NodeIterator](self)

pub fun NodeIterator::from_js(v: JsValue) -> mut NodeIterator = JsValue::unsafe_as[mut NodeIterator](v)

struct TreeWalker()

pub ext fun TreeWalker::root(self: TreeWalker) -> mut Node
    = "return #fun(Node::from_js)(#var(self).root);"

pub ext fun TreeWalker::what_to_show(self: TreeWalker) -> Int
    = "return #fun(Int::from_js)(#var(self).whatToShow);"

pub ext fun TreeWalker::filter(self: TreeWalker) -> Option[Fun(mut Node) -> Int]
    = "return #fun(Option::from_js[Fun(mut Node) -> Int])(#var(self).filter);"

pub ext fun TreeWalker::current_node(self: TreeWalker) -> mut Node
    = "return #fun(Node::from_js)(#var(self).currentNode);"

pub ext fun TreeWalker::set_current_node(self: mut TreeWalker, value: mut Node)
    = "#var(self).currentNode = #fun(Node::as_js)(#var(value));"

pub ext fun TreeWalker::parent_node(__self: mut TreeWalker) -> Option[mut Node] = "
    const r = #var(__self).parentNode();
    return #fun(Option::from_js[mut Node])(r);
"

pub ext fun TreeWalker::first_child(__self: mut TreeWalker) -> Option[mut Node] = "
    const r = #var(__self).firstChild();
    return #fun(Option::from_js[mut Node])(r);
"

pub ext fun TreeWalker::last_child(__self: mut TreeWalker) -> Option[mut Node] = "
    const r = #var(__self).lastChild();
    return #fun(Option::from_js[mut Node])(r);
"

pub ext fun TreeWalker::previous_sibling(__self: mut TreeWalker) -> Option[mut Node] = "
    const r = #var(__self).previousSibling();
    return #fun(Option::from_js[mut Node])(r);
"

pub ext fun TreeWalker::next_sibling(__self: mut TreeWalker) -> Option[mut Node] = "
    const r = #var(__self).nextSibling();
    return #fun(Option::from_js[mut Node])(r);
"

pub ext fun TreeWalker::previous_node(__self: mut TreeWalker) -> Option[mut Node] = "
    const r = #var(__self).previousNode();
    return #fun(Option::from_js[mut Node])(r);
"

pub ext fun TreeWalker::next_node(__self: mut TreeWalker) -> Option[mut Node] = "
    const r = #var(__self).nextNode();
    return #fun(Option::from_js[mut Node])(r);
"

pub fun TreeWalker::as_js(self: TreeWalker) -> JsValue = JsValue::unsafe_from[TreeWalker](self)

pub fun TreeWalker::from_js(v: JsValue) -> mut TreeWalker = JsValue::unsafe_as[mut TreeWalker](v)

pub val NodeFilter::FILTER_ACCEPT: Int = 1
pub val NodeFilter::FILTER_REJECT: Int = 2
pub val NodeFilter::FILTER_SKIP: Int = 3
pub val NodeFilter::SHOW_ALL: Int = 4294967295
pub val NodeFilter::SHOW_ELEMENT: Int = 1
pub val NodeFilter::SHOW_ATTRIBUTE: Int = 2
pub val NodeFilter::SHOW_TEXT: Int = 4
pub val NodeFilter::SHOW_CDATA_SECTION: Int = 8
pub val NodeFilter::SHOW_ENTITY_REFERENCE: Int = 16
pub val NodeFilter::SHOW_ENTITY: Int = 32
pub val NodeFilter::SHOW_PROCESSING_INSTRUCTION: Int = 64
pub val NodeFilter::SHOW_COMMENT: Int = 128
pub val NodeFilter::SHOW_DOCUMENT: Int = 256
pub val NodeFilter::SHOW_DOCUMENT_TYPE: Int = 512
pub val NodeFilter::SHOW_DOCUMENT_FRAGMENT: Int = 1024
pub val NodeFilter::SHOW_NOTATION: Int = 2048

struct DOMTokenList()

pub ext fun DOMTokenList::length(self: DOMTokenList) -> Int
    = "return #fun(Int::from_js)(#var(self).length);"

pub ext fun DOMTokenList::value(self: DOMTokenList) -> String
    = "return #fun(String::from_js)(#var(self).value);"

pub ext fun DOMTokenList::set_value(self: mut DOMTokenList, value: String)
    = "#var(self).value = #fun(String::as_js)(#var(value));"

pub ext fun DOMTokenList::item(__self: mut DOMTokenList, index: Int) -> Option[String] = "
    const r = #var(__self).item(#fun(Int::as_js)(#var(index)));
    return #fun(Option::from_js[String])(r);
"

pub ext fun DOMTokenList::contains(__self: mut DOMTokenList, token: String) -> Bool = "
    const r = #var(__self).contains(#fun(String::as_js)(#var(token)));
    return #fun(Bool::from_js)(r);
"

pub ext fun DOMTokenList::add(__self: mut DOMTokenList, ...tokens: List[String]) -> Unit = "
    const r = #var(__self).add((#var(tokens)).map(v => #fun(String::as_js)(v)));
    return #fun(Unit::from_js)(r);
"

pub ext fun DOMTokenList::remove(__self: mut DOMTokenList, ...tokens: List[String]) -> Unit = "
    const r = #var(__self).remove((#var(tokens)).map(v => #fun(String::as_js)(v)));
    return #fun(Unit::from_js)(r);
"

pub ext fun DOMTokenList::toggle(__self: mut DOMTokenList, token: String, force: Bool) -> Bool = "
    const r = #var(__self).toggle(#fun(String::as_js)(#var(token)), #fun(Bool::as_js)(#var(force)));
    return #fun(Bool::from_js)(r);
"

pub ext fun DOMTokenList::replace(__self: mut DOMTokenList, token: String, new_token: String) -> Bool = "
    const r = #var(__self).replace(#fun(String::as_js)(#var(token)), #fun(String::as_js)(#var(new_token)));
    return #fun(Bool::from_js)(r);
"

pub ext fun DOMTokenList::supports(__self: mut DOMTokenList, token: String) -> Bool = "
    const r = #var(__self).supports(#fun(String::as_js)(#var(token)));
    return #fun(Bool::from_js)(r);
"

pub fun DOMTokenList::as_js(self: DOMTokenList) -> JsValue = JsValue::unsafe_from[DOMTokenList](self)

pub fun DOMTokenList::from_js(v: JsValue) -> mut DOMTokenList = JsValue::unsafe_as[mut DOMTokenList](v)

struct XPathResult()

pub ext fun XPathResult::result_type(self: XPathResult) -> Int
    = "return #fun(Int::from_js)(#var(self).resultType);"

pub ext fun XPathResult::number_value(self: XPathResult) -> Float
    = "return #fun(Float::from_js)(#var(self).numberValue);"

pub ext fun XPathResult::string_value(self: XPathResult) -> String
    = "return #fun(String::from_js)(#var(self).stringValue);"

pub ext fun XPathResult::boolean_value(self: XPathResult) -> Bool
    = "return #fun(Bool::from_js)(#var(self).booleanValue);"

pub ext fun XPathResult::single_node_value(self: XPathResult) -> Option[mut Node]
    = "return #fun(Option::from_js[mut Node])(#var(self).singleNodeValue);"

pub ext fun XPathResult::invalid_iterator_state(self: XPathResult) -> Bool
    = "return #fun(Bool::from_js)(#var(self).invalidIteratorState);"

pub ext fun XPathResult::snapshot_length(self: XPathResult) -> Int
    = "return #fun(Int::from_js)(#var(self).snapshotLength);"

pub ext fun XPathResult::iterate_next(__self: mut XPathResult) -> Option[mut Node] = "
    const r = #var(__self).iterateNext();
    return #fun(Option::from_js[mut Node])(r);
"

pub ext fun XPathResult::snapshot_item(__self: mut XPathResult, index: Int) -> Option[mut Node] = "
    const r = #var(__self).snapshotItem(#fun(Int::as_js)(#var(index)));
    return #fun(Option::from_js[mut Node])(r);
"

pub fun XPathResult::as_js(self: XPathResult) -> JsValue = JsValue::unsafe_from[XPathResult](self)

pub fun XPathResult::from_js(v: JsValue) -> mut XPathResult = JsValue::unsafe_as[mut XPathResult](v)

pub val XPathResult::ANY_TYPE: Int = 0
pub val XPathResult::NUMBER_TYPE: Int = 1
pub val XPathResult::STRING_TYPE: Int = 2
pub val XPathResult::BOOLEAN_TYPE: Int = 3
pub val XPathResult::UNORDERED_NODE_ITERATOR_TYPE: Int = 4
pub val XPathResult::ORDERED_NODE_ITERATOR_TYPE: Int = 5
pub val XPathResult::UNORDERED_NODE_SNAPSHOT_TYPE: Int = 6
pub val XPathResult::ORDERED_NODE_SNAPSHOT_TYPE: Int = 7
pub val XPathResult::ANY_UNORDERED_NODE_TYPE: Int = 8
pub val XPathResult::FIRST_ORDERED_NODE_TYPE: Int = 9

struct XPathExpression()

pub ext fun XPathExpression::evaluate(__self: mut XPathExpression, context_node: mut Node, type: Int, result: Option[mut XPathResult]) -> mut XPathResult = "
    const r = #var(__self).evaluate(#fun(Node::as_js)(#var(context_node)), #fun(Int::as_js)(#var(type)), #fun(Option::as_js[mut XPathResult])(#var(result)));
    return #fun(XPathResult::from_js)(r);
"

pub fun XPathExpression::as_js(self: XPathExpression) -> JsValue = JsValue::unsafe_from[XPathExpression](self)

pub fun XPathExpression::from_js(v: JsValue) -> mut XPathExpression = JsValue::unsafe_as[mut XPathExpression](v)

struct XPathEvaluator()

pub ext fun XPathEvaluator::new() -> mut XPathEvaluator
    = "new XPathEvaluator();"

pub ext fun XPathEvaluator::create_expression(__self: mut XPathEvaluator, expression: String, resolver: Option[Fun(Option[String]) -> Option[String]]) -> mut XPathExpression = "
    const r = #var(__self).createExpression(#fun(String::as_js)(#var(expression)), #fun(Option::as_js[Fun(Option[String]) -> Option[String]])(#var(resolver)));
    return #fun(XPathExpression::from_js)(r);
"

pub ext fun XPathEvaluator::create_ns_resolver(__self: mut XPathEvaluator, node_resolver: mut Node) -> mut Node = "
    const r = #var(__self).createNSResolver(#fun(Node::as_js)(#var(node_resolver)));
    return #fun(Node::from_js)(r);
"

pub ext fun XPathEvaluator::evaluate(__self: mut XPathEvaluator, expression: String, context_node: mut Node, resolver: Option[Fun(Option[String]) -> Option[String]], type: Int, result: Option[mut XPathResult]) -> mut XPathResult = "
    const r = #var(__self).evaluate(#fun(String::as_js)(#var(expression)), #fun(Node::as_js)(#var(context_node)), #fun(Option::as_js[Fun(Option[String]) -> Option[String]])(#var(resolver)), #fun(Int::as_js)(#var(type)), #fun(Option::as_js[mut XPathResult])(#var(result)));
    return #fun(XPathResult::from_js)(r);
"

pub fun XPathEvaluator::as_js(self: XPathEvaluator) -> JsValue = JsValue::unsafe_from[XPathEvaluator](self)

pub fun XPathEvaluator::from_js(v: JsValue) -> mut XPathEvaluator = JsValue::unsafe_as[mut XPathEvaluator](v)

struct XSLTProcessor()

pub ext fun XSLTProcessor::new() -> mut XSLTProcessor
    = "new XSLTProcessor();"

pub ext fun XSLTProcessor::import_stylesheet(__self: mut XSLTProcessor, style: mut Node) -> Unit = "
    const r = #var(__self).importStylesheet(#fun(Node::as_js)(#var(style)));
    return #fun(Unit::from_js)(r);
"

pub ext fun XSLTProcessor::transform_to_fragment(__self: mut XSLTProcessor, source: mut Node, output: mut Document) -> mut DocumentFragment = "
    const r = #var(__self).transformToFragment(#fun(Node::as_js)(#var(source)), #fun(Document::as_js)(#var(output)));
    return #fun(DocumentFragment::from_js)(r);
"

pub ext fun XSLTProcessor::transform_to_document(__self: mut XSLTProcessor, source: mut Node) -> mut Document = "
    const r = #var(__self).transformToDocument(#fun(Node::as_js)(#var(source)));
    return #fun(Document::from_js)(r);
"

pub ext fun XSLTProcessor::set_parameter(__self: mut XSLTProcessor, namespace_uri: String, local_name: String, value: JsValue) -> Unit = "
    const r = #var(__self).setParameter(#fun(String::as_js)(#var(namespace_uri)), #fun(String::as_js)(#var(local_name)), #var(value));
    return #fun(Unit::from_js)(r);
"

pub ext fun XSLTProcessor::get_parameter(__self: mut XSLTProcessor, namespace_uri: String, local_name: String) -> JsValue = "
    const r = #var(__self).getParameter(#fun(String::as_js)(#var(namespace_uri)), #fun(String::as_js)(#var(local_name)));
    return r;
"

pub ext fun XSLTProcessor::remove_parameter(__self: mut XSLTProcessor, namespace_uri: String, local_name: String) -> Unit = "
    const r = #var(__self).removeParameter(#fun(String::as_js)(#var(namespace_uri)), #fun(String::as_js)(#var(local_name)));
    return #fun(Unit::from_js)(r);
"

pub ext fun XSLTProcessor::clear_parameters(__self: mut XSLTProcessor) -> Unit = "
    const r = #var(__self).clearParameters();
    return #fun(Unit::from_js)(r);
"

pub ext fun XSLTProcessor::reset(__self: mut XSLTProcessor) -> Unit = "
    const r = #var(__self).reset();
    return #fun(Unit::from_js)(r);
"

pub fun XSLTProcessor::as_js(self: XSLTProcessor) -> JsValue = JsValue::unsafe_from[XSLTProcessor](self)

pub fun XSLTProcessor::from_js(v: JsValue) -> mut XSLTProcessor = JsValue::unsafe_as[mut XSLTProcessor](v)

